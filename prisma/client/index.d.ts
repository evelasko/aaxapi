// Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  address: (where?: AddressWhereInput) => Promise<boolean>;
  branch: (where?: BranchWhereInput) => Promise<boolean>;
  department: (where?: DepartmentWhereInput) => Promise<boolean>;
  device: (where?: DeviceWhereInput) => Promise<boolean>;
  discount: (where?: DiscountWhereInput) => Promise<boolean>;
  discountRequest: (where?: DiscountRequestWhereInput) => Promise<boolean>;
  event: (where?: EventWhereInput) => Promise<boolean>;
  item: (where?: ItemWhereInput) => Promise<boolean>;
  lesson: (where?: LessonWhereInput) => Promise<boolean>;
  news: (where?: NewsWhereInput) => Promise<boolean>;
  officialDocument: (where?: OfficialDocumentWhereInput) => Promise<boolean>;
  operatingPeriod: (where?: OperatingPeriodWhereInput) => Promise<boolean>;
  order: (where?: OrderWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  productCategory: (where?: ProductCategoryWhereInput) => Promise<boolean>;
  program: (where?: ProgramWhereInput) => Promise<boolean>;
  role: (where?: RoleWhereInput) => Promise<boolean>;
  session: (where?: SessionWhereInput) => Promise<boolean>;
  socialLink: (where?: SocialLinkWhereInput) => Promise<boolean>;
  socialNetwork: (where?: SocialNetworkWhereInput) => Promise<boolean>;
  space: (where?: SpaceWhereInput) => Promise<boolean>;
  subject: (where?: SubjectWhereInput) => Promise<boolean>;
  transaction: (where?: TransactionWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  venue: (where?: VenueWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  address: (where: AddressWhereUniqueInput) => AddressNullablePromise;
  addresses: (args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Address>;
  addressesConnection: (args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AddressConnectionPromise;
  branch: (where: BranchWhereUniqueInput) => BranchNullablePromise;
  branches: (args?: {
    where?: BranchWhereInput;
    orderBy?: BranchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Branch>;
  branchesConnection: (args?: {
    where?: BranchWhereInput;
    orderBy?: BranchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BranchConnectionPromise;
  department: (where: DepartmentWhereUniqueInput) => DepartmentNullablePromise;
  departments: (args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Department>;
  departmentsConnection: (args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DepartmentConnectionPromise;
  device: (where: DeviceWhereUniqueInput) => DeviceNullablePromise;
  devices: (args?: {
    where?: DeviceWhereInput;
    orderBy?: DeviceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Device>;
  devicesConnection: (args?: {
    where?: DeviceWhereInput;
    orderBy?: DeviceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DeviceConnectionPromise;
  discount: (where: DiscountWhereUniqueInput) => DiscountNullablePromise;
  discounts: (args?: {
    where?: DiscountWhereInput;
    orderBy?: DiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Discount>;
  discountsConnection: (args?: {
    where?: DiscountWhereInput;
    orderBy?: DiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DiscountConnectionPromise;
  discountRequest: (
    where: DiscountRequestWhereUniqueInput
  ) => DiscountRequestNullablePromise;
  discountRequests: (args?: {
    where?: DiscountRequestWhereInput;
    orderBy?: DiscountRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DiscountRequest>;
  discountRequestsConnection: (args?: {
    where?: DiscountRequestWhereInput;
    orderBy?: DiscountRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DiscountRequestConnectionPromise;
  event: (where: EventWhereUniqueInput) => EventNullablePromise;
  events: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Event>;
  eventsConnection: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EventConnectionPromise;
  item: (where: ItemWhereUniqueInput) => ItemNullablePromise;
  items: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Item>;
  itemsConnection: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ItemConnectionPromise;
  lesson: (where: LessonWhereUniqueInput) => LessonNullablePromise;
  lessons: (args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Lesson>;
  lessonsConnection: (args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LessonConnectionPromise;
  news: (where: NewsWhereUniqueInput) => NewsNullablePromise;
  newses: (args?: {
    where?: NewsWhereInput;
    orderBy?: NewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<News>;
  newsesConnection: (args?: {
    where?: NewsWhereInput;
    orderBy?: NewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NewsConnectionPromise;
  officialDocument: (
    where: OfficialDocumentWhereUniqueInput
  ) => OfficialDocumentNullablePromise;
  officialDocuments: (args?: {
    where?: OfficialDocumentWhereInput;
    orderBy?: OfficialDocumentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OfficialDocument>;
  officialDocumentsConnection: (args?: {
    where?: OfficialDocumentWhereInput;
    orderBy?: OfficialDocumentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OfficialDocumentConnectionPromise;
  operatingPeriod: (
    where: OperatingPeriodWhereUniqueInput
  ) => OperatingPeriodNullablePromise;
  operatingPeriods: (args?: {
    where?: OperatingPeriodWhereInput;
    orderBy?: OperatingPeriodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OperatingPeriod>;
  operatingPeriodsConnection: (args?: {
    where?: OperatingPeriodWhereInput;
    orderBy?: OperatingPeriodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OperatingPeriodConnectionPromise;
  order: (where: OrderWhereUniqueInput) => OrderNullablePromise;
  orders: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Order>;
  ordersConnection: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductNullablePromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  productCategory: (
    where: ProductCategoryWhereUniqueInput
  ) => ProductCategoryNullablePromise;
  productCategories: (args?: {
    where?: ProductCategoryWhereInput;
    orderBy?: ProductCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductCategory>;
  productCategoriesConnection: (args?: {
    where?: ProductCategoryWhereInput;
    orderBy?: ProductCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductCategoryConnectionPromise;
  program: (where: ProgramWhereUniqueInput) => ProgramNullablePromise;
  programs: (args?: {
    where?: ProgramWhereInput;
    orderBy?: ProgramOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Program>;
  programsConnection: (args?: {
    where?: ProgramWhereInput;
    orderBy?: ProgramOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProgramConnectionPromise;
  role: (where: RoleWhereUniqueInput) => RoleNullablePromise;
  roles: (args?: {
    where?: RoleWhereInput;
    orderBy?: RoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Role>;
  rolesConnection: (args?: {
    where?: RoleWhereInput;
    orderBy?: RoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RoleConnectionPromise;
  session: (where: SessionWhereUniqueInput) => SessionNullablePromise;
  sessions: (args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Session>;
  sessionsConnection: (args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SessionConnectionPromise;
  socialLink: (where: SocialLinkWhereUniqueInput) => SocialLinkNullablePromise;
  socialLinks: (args?: {
    where?: SocialLinkWhereInput;
    orderBy?: SocialLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SocialLink>;
  socialLinksConnection: (args?: {
    where?: SocialLinkWhereInput;
    orderBy?: SocialLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SocialLinkConnectionPromise;
  socialNetwork: (
    where: SocialNetworkWhereUniqueInput
  ) => SocialNetworkNullablePromise;
  socialNetworks: (args?: {
    where?: SocialNetworkWhereInput;
    orderBy?: SocialNetworkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SocialNetwork>;
  socialNetworksConnection: (args?: {
    where?: SocialNetworkWhereInput;
    orderBy?: SocialNetworkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SocialNetworkConnectionPromise;
  space: (where: SpaceWhereUniqueInput) => SpaceNullablePromise;
  spaces: (args?: {
    where?: SpaceWhereInput;
    orderBy?: SpaceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Space>;
  spacesConnection: (args?: {
    where?: SpaceWhereInput;
    orderBy?: SpaceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SpaceConnectionPromise;
  subject: (where: SubjectWhereUniqueInput) => SubjectNullablePromise;
  subjects: (args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Subject>;
  subjectsConnection: (args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubjectConnectionPromise;
  transaction: (
    where: TransactionWhereUniqueInput
  ) => TransactionNullablePromise;
  transactions: (args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Transaction>;
  transactionsConnection: (args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TransactionConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  venue: (where: VenueWhereUniqueInput) => VenueNullablePromise;
  venues: (args?: {
    where?: VenueWhereInput;
    orderBy?: VenueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Venue>;
  venuesConnection: (args?: {
    where?: VenueWhereInput;
    orderBy?: VenueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VenueConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAddress: (data: AddressCreateInput) => AddressPromise;
  updateAddress: (args: {
    data: AddressUpdateInput;
    where: AddressWhereUniqueInput;
  }) => AddressPromise;
  updateManyAddresses: (args: {
    data: AddressUpdateManyMutationInput;
    where?: AddressWhereInput;
  }) => BatchPayloadPromise;
  upsertAddress: (args: {
    where: AddressWhereUniqueInput;
    create: AddressCreateInput;
    update: AddressUpdateInput;
  }) => AddressPromise;
  deleteAddress: (where: AddressWhereUniqueInput) => AddressPromise;
  deleteManyAddresses: (where?: AddressWhereInput) => BatchPayloadPromise;
  createBranch: (data: BranchCreateInput) => BranchPromise;
  updateBranch: (args: {
    data: BranchUpdateInput;
    where: BranchWhereUniqueInput;
  }) => BranchPromise;
  updateManyBranches: (args: {
    data: BranchUpdateManyMutationInput;
    where?: BranchWhereInput;
  }) => BatchPayloadPromise;
  upsertBranch: (args: {
    where: BranchWhereUniqueInput;
    create: BranchCreateInput;
    update: BranchUpdateInput;
  }) => BranchPromise;
  deleteBranch: (where: BranchWhereUniqueInput) => BranchPromise;
  deleteManyBranches: (where?: BranchWhereInput) => BatchPayloadPromise;
  createDepartment: (data: DepartmentCreateInput) => DepartmentPromise;
  updateDepartment: (args: {
    data: DepartmentUpdateInput;
    where: DepartmentWhereUniqueInput;
  }) => DepartmentPromise;
  updateManyDepartments: (args: {
    data: DepartmentUpdateManyMutationInput;
    where?: DepartmentWhereInput;
  }) => BatchPayloadPromise;
  upsertDepartment: (args: {
    where: DepartmentWhereUniqueInput;
    create: DepartmentCreateInput;
    update: DepartmentUpdateInput;
  }) => DepartmentPromise;
  deleteDepartment: (where: DepartmentWhereUniqueInput) => DepartmentPromise;
  deleteManyDepartments: (where?: DepartmentWhereInput) => BatchPayloadPromise;
  createDevice: (data: DeviceCreateInput) => DevicePromise;
  updateDevice: (args: {
    data: DeviceUpdateInput;
    where: DeviceWhereUniqueInput;
  }) => DevicePromise;
  updateManyDevices: (args: {
    data: DeviceUpdateManyMutationInput;
    where?: DeviceWhereInput;
  }) => BatchPayloadPromise;
  upsertDevice: (args: {
    where: DeviceWhereUniqueInput;
    create: DeviceCreateInput;
    update: DeviceUpdateInput;
  }) => DevicePromise;
  deleteDevice: (where: DeviceWhereUniqueInput) => DevicePromise;
  deleteManyDevices: (where?: DeviceWhereInput) => BatchPayloadPromise;
  createDiscount: (data: DiscountCreateInput) => DiscountPromise;
  updateDiscount: (args: {
    data: DiscountUpdateInput;
    where: DiscountWhereUniqueInput;
  }) => DiscountPromise;
  updateManyDiscounts: (args: {
    data: DiscountUpdateManyMutationInput;
    where?: DiscountWhereInput;
  }) => BatchPayloadPromise;
  upsertDiscount: (args: {
    where: DiscountWhereUniqueInput;
    create: DiscountCreateInput;
    update: DiscountUpdateInput;
  }) => DiscountPromise;
  deleteDiscount: (where: DiscountWhereUniqueInput) => DiscountPromise;
  deleteManyDiscounts: (where?: DiscountWhereInput) => BatchPayloadPromise;
  createDiscountRequest: (
    data: DiscountRequestCreateInput
  ) => DiscountRequestPromise;
  updateDiscountRequest: (args: {
    data: DiscountRequestUpdateInput;
    where: DiscountRequestWhereUniqueInput;
  }) => DiscountRequestPromise;
  updateManyDiscountRequests: (args: {
    data: DiscountRequestUpdateManyMutationInput;
    where?: DiscountRequestWhereInput;
  }) => BatchPayloadPromise;
  upsertDiscountRequest: (args: {
    where: DiscountRequestWhereUniqueInput;
    create: DiscountRequestCreateInput;
    update: DiscountRequestUpdateInput;
  }) => DiscountRequestPromise;
  deleteDiscountRequest: (
    where: DiscountRequestWhereUniqueInput
  ) => DiscountRequestPromise;
  deleteManyDiscountRequests: (
    where?: DiscountRequestWhereInput
  ) => BatchPayloadPromise;
  createEvent: (data: EventCreateInput) => EventPromise;
  updateEvent: (args: {
    data: EventUpdateInput;
    where: EventWhereUniqueInput;
  }) => EventPromise;
  updateManyEvents: (args: {
    data: EventUpdateManyMutationInput;
    where?: EventWhereInput;
  }) => BatchPayloadPromise;
  upsertEvent: (args: {
    where: EventWhereUniqueInput;
    create: EventCreateInput;
    update: EventUpdateInput;
  }) => EventPromise;
  deleteEvent: (where: EventWhereUniqueInput) => EventPromise;
  deleteManyEvents: (where?: EventWhereInput) => BatchPayloadPromise;
  createItem: (data: ItemCreateInput) => ItemPromise;
  updateItem: (args: {
    data: ItemUpdateInput;
    where: ItemWhereUniqueInput;
  }) => ItemPromise;
  updateManyItems: (args: {
    data: ItemUpdateManyMutationInput;
    where?: ItemWhereInput;
  }) => BatchPayloadPromise;
  upsertItem: (args: {
    where: ItemWhereUniqueInput;
    create: ItemCreateInput;
    update: ItemUpdateInput;
  }) => ItemPromise;
  deleteItem: (where: ItemWhereUniqueInput) => ItemPromise;
  deleteManyItems: (where?: ItemWhereInput) => BatchPayloadPromise;
  createLesson: (data: LessonCreateInput) => LessonPromise;
  updateLesson: (args: {
    data: LessonUpdateInput;
    where: LessonWhereUniqueInput;
  }) => LessonPromise;
  updateManyLessons: (args: {
    data: LessonUpdateManyMutationInput;
    where?: LessonWhereInput;
  }) => BatchPayloadPromise;
  upsertLesson: (args: {
    where: LessonWhereUniqueInput;
    create: LessonCreateInput;
    update: LessonUpdateInput;
  }) => LessonPromise;
  deleteLesson: (where: LessonWhereUniqueInput) => LessonPromise;
  deleteManyLessons: (where?: LessonWhereInput) => BatchPayloadPromise;
  createNews: (data: NewsCreateInput) => NewsPromise;
  updateNews: (args: {
    data: NewsUpdateInput;
    where: NewsWhereUniqueInput;
  }) => NewsPromise;
  updateManyNewses: (args: {
    data: NewsUpdateManyMutationInput;
    where?: NewsWhereInput;
  }) => BatchPayloadPromise;
  upsertNews: (args: {
    where: NewsWhereUniqueInput;
    create: NewsCreateInput;
    update: NewsUpdateInput;
  }) => NewsPromise;
  deleteNews: (where: NewsWhereUniqueInput) => NewsPromise;
  deleteManyNewses: (where?: NewsWhereInput) => BatchPayloadPromise;
  createOfficialDocument: (
    data: OfficialDocumentCreateInput
  ) => OfficialDocumentPromise;
  updateOfficialDocument: (args: {
    data: OfficialDocumentUpdateInput;
    where: OfficialDocumentWhereUniqueInput;
  }) => OfficialDocumentPromise;
  updateManyOfficialDocuments: (args: {
    data: OfficialDocumentUpdateManyMutationInput;
    where?: OfficialDocumentWhereInput;
  }) => BatchPayloadPromise;
  upsertOfficialDocument: (args: {
    where: OfficialDocumentWhereUniqueInput;
    create: OfficialDocumentCreateInput;
    update: OfficialDocumentUpdateInput;
  }) => OfficialDocumentPromise;
  deleteOfficialDocument: (
    where: OfficialDocumentWhereUniqueInput
  ) => OfficialDocumentPromise;
  deleteManyOfficialDocuments: (
    where?: OfficialDocumentWhereInput
  ) => BatchPayloadPromise;
  createOperatingPeriod: (
    data: OperatingPeriodCreateInput
  ) => OperatingPeriodPromise;
  updateOperatingPeriod: (args: {
    data: OperatingPeriodUpdateInput;
    where: OperatingPeriodWhereUniqueInput;
  }) => OperatingPeriodPromise;
  updateManyOperatingPeriods: (args: {
    data: OperatingPeriodUpdateManyMutationInput;
    where?: OperatingPeriodWhereInput;
  }) => BatchPayloadPromise;
  upsertOperatingPeriod: (args: {
    where: OperatingPeriodWhereUniqueInput;
    create: OperatingPeriodCreateInput;
    update: OperatingPeriodUpdateInput;
  }) => OperatingPeriodPromise;
  deleteOperatingPeriod: (
    where: OperatingPeriodWhereUniqueInput
  ) => OperatingPeriodPromise;
  deleteManyOperatingPeriods: (
    where?: OperatingPeriodWhereInput
  ) => BatchPayloadPromise;
  createOrder: (data: OrderCreateInput) => OrderPromise;
  updateOrder: (args: {
    data: OrderUpdateInput;
    where: OrderWhereUniqueInput;
  }) => OrderPromise;
  updateManyOrders: (args: {
    data: OrderUpdateManyMutationInput;
    where?: OrderWhereInput;
  }) => BatchPayloadPromise;
  upsertOrder: (args: {
    where: OrderWhereUniqueInput;
    create: OrderCreateInput;
    update: OrderUpdateInput;
  }) => OrderPromise;
  deleteOrder: (where: OrderWhereUniqueInput) => OrderPromise;
  deleteManyOrders: (where?: OrderWhereInput) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createProductCategory: (
    data: ProductCategoryCreateInput
  ) => ProductCategoryPromise;
  updateProductCategory: (args: {
    data: ProductCategoryUpdateInput;
    where: ProductCategoryWhereUniqueInput;
  }) => ProductCategoryPromise;
  updateManyProductCategories: (args: {
    data: ProductCategoryUpdateManyMutationInput;
    where?: ProductCategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertProductCategory: (args: {
    where: ProductCategoryWhereUniqueInput;
    create: ProductCategoryCreateInput;
    update: ProductCategoryUpdateInput;
  }) => ProductCategoryPromise;
  deleteProductCategory: (
    where: ProductCategoryWhereUniqueInput
  ) => ProductCategoryPromise;
  deleteManyProductCategories: (
    where?: ProductCategoryWhereInput
  ) => BatchPayloadPromise;
  createProgram: (data: ProgramCreateInput) => ProgramPromise;
  updateProgram: (args: {
    data: ProgramUpdateInput;
    where: ProgramWhereUniqueInput;
  }) => ProgramPromise;
  updateManyPrograms: (args: {
    data: ProgramUpdateManyMutationInput;
    where?: ProgramWhereInput;
  }) => BatchPayloadPromise;
  upsertProgram: (args: {
    where: ProgramWhereUniqueInput;
    create: ProgramCreateInput;
    update: ProgramUpdateInput;
  }) => ProgramPromise;
  deleteProgram: (where: ProgramWhereUniqueInput) => ProgramPromise;
  deleteManyPrograms: (where?: ProgramWhereInput) => BatchPayloadPromise;
  createRole: (data: RoleCreateInput) => RolePromise;
  updateRole: (args: {
    data: RoleUpdateInput;
    where: RoleWhereUniqueInput;
  }) => RolePromise;
  updateManyRoles: (args: {
    data: RoleUpdateManyMutationInput;
    where?: RoleWhereInput;
  }) => BatchPayloadPromise;
  upsertRole: (args: {
    where: RoleWhereUniqueInput;
    create: RoleCreateInput;
    update: RoleUpdateInput;
  }) => RolePromise;
  deleteRole: (where: RoleWhereUniqueInput) => RolePromise;
  deleteManyRoles: (where?: RoleWhereInput) => BatchPayloadPromise;
  createSession: (data: SessionCreateInput) => SessionPromise;
  updateSession: (args: {
    data: SessionUpdateInput;
    where: SessionWhereUniqueInput;
  }) => SessionPromise;
  updateManySessions: (args: {
    data: SessionUpdateManyMutationInput;
    where?: SessionWhereInput;
  }) => BatchPayloadPromise;
  upsertSession: (args: {
    where: SessionWhereUniqueInput;
    create: SessionCreateInput;
    update: SessionUpdateInput;
  }) => SessionPromise;
  deleteSession: (where: SessionWhereUniqueInput) => SessionPromise;
  deleteManySessions: (where?: SessionWhereInput) => BatchPayloadPromise;
  createSocialLink: (data: SocialLinkCreateInput) => SocialLinkPromise;
  updateSocialLink: (args: {
    data: SocialLinkUpdateInput;
    where: SocialLinkWhereUniqueInput;
  }) => SocialLinkPromise;
  updateManySocialLinks: (args: {
    data: SocialLinkUpdateManyMutationInput;
    where?: SocialLinkWhereInput;
  }) => BatchPayloadPromise;
  upsertSocialLink: (args: {
    where: SocialLinkWhereUniqueInput;
    create: SocialLinkCreateInput;
    update: SocialLinkUpdateInput;
  }) => SocialLinkPromise;
  deleteSocialLink: (where: SocialLinkWhereUniqueInput) => SocialLinkPromise;
  deleteManySocialLinks: (where?: SocialLinkWhereInput) => BatchPayloadPromise;
  createSocialNetwork: (data: SocialNetworkCreateInput) => SocialNetworkPromise;
  updateSocialNetwork: (args: {
    data: SocialNetworkUpdateInput;
    where: SocialNetworkWhereUniqueInput;
  }) => SocialNetworkPromise;
  updateManySocialNetworks: (args: {
    data: SocialNetworkUpdateManyMutationInput;
    where?: SocialNetworkWhereInput;
  }) => BatchPayloadPromise;
  upsertSocialNetwork: (args: {
    where: SocialNetworkWhereUniqueInput;
    create: SocialNetworkCreateInput;
    update: SocialNetworkUpdateInput;
  }) => SocialNetworkPromise;
  deleteSocialNetwork: (
    where: SocialNetworkWhereUniqueInput
  ) => SocialNetworkPromise;
  deleteManySocialNetworks: (
    where?: SocialNetworkWhereInput
  ) => BatchPayloadPromise;
  createSpace: (data: SpaceCreateInput) => SpacePromise;
  updateSpace: (args: {
    data: SpaceUpdateInput;
    where: SpaceWhereUniqueInput;
  }) => SpacePromise;
  updateManySpaces: (args: {
    data: SpaceUpdateManyMutationInput;
    where?: SpaceWhereInput;
  }) => BatchPayloadPromise;
  upsertSpace: (args: {
    where: SpaceWhereUniqueInput;
    create: SpaceCreateInput;
    update: SpaceUpdateInput;
  }) => SpacePromise;
  deleteSpace: (where: SpaceWhereUniqueInput) => SpacePromise;
  deleteManySpaces: (where?: SpaceWhereInput) => BatchPayloadPromise;
  createSubject: (data: SubjectCreateInput) => SubjectPromise;
  updateSubject: (args: {
    data: SubjectUpdateInput;
    where: SubjectWhereUniqueInput;
  }) => SubjectPromise;
  updateManySubjects: (args: {
    data: SubjectUpdateManyMutationInput;
    where?: SubjectWhereInput;
  }) => BatchPayloadPromise;
  upsertSubject: (args: {
    where: SubjectWhereUniqueInput;
    create: SubjectCreateInput;
    update: SubjectUpdateInput;
  }) => SubjectPromise;
  deleteSubject: (where: SubjectWhereUniqueInput) => SubjectPromise;
  deleteManySubjects: (where?: SubjectWhereInput) => BatchPayloadPromise;
  createTransaction: (data: TransactionCreateInput) => TransactionPromise;
  updateTransaction: (args: {
    data: TransactionUpdateInput;
    where: TransactionWhereUniqueInput;
  }) => TransactionPromise;
  updateManyTransactions: (args: {
    data: TransactionUpdateManyMutationInput;
    where?: TransactionWhereInput;
  }) => BatchPayloadPromise;
  upsertTransaction: (args: {
    where: TransactionWhereUniqueInput;
    create: TransactionCreateInput;
    update: TransactionUpdateInput;
  }) => TransactionPromise;
  deleteTransaction: (where: TransactionWhereUniqueInput) => TransactionPromise;
  deleteManyTransactions: (
    where?: TransactionWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVenue: (data: VenueCreateInput) => VenuePromise;
  updateVenue: (args: {
    data: VenueUpdateInput;
    where: VenueWhereUniqueInput;
  }) => VenuePromise;
  updateManyVenues: (args: {
    data: VenueUpdateManyMutationInput;
    where?: VenueWhereInput;
  }) => BatchPayloadPromise;
  upsertVenue: (args: {
    where: VenueWhereUniqueInput;
    create: VenueCreateInput;
    update: VenueUpdateInput;
  }) => VenuePromise;
  deleteVenue: (where: VenueWhereUniqueInput) => VenuePromise;
  deleteManyVenues: (where?: VenueWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  address: (
    where?: AddressSubscriptionWhereInput
  ) => AddressSubscriptionPayloadSubscription;
  branch: (
    where?: BranchSubscriptionWhereInput
  ) => BranchSubscriptionPayloadSubscription;
  department: (
    where?: DepartmentSubscriptionWhereInput
  ) => DepartmentSubscriptionPayloadSubscription;
  device: (
    where?: DeviceSubscriptionWhereInput
  ) => DeviceSubscriptionPayloadSubscription;
  discount: (
    where?: DiscountSubscriptionWhereInput
  ) => DiscountSubscriptionPayloadSubscription;
  discountRequest: (
    where?: DiscountRequestSubscriptionWhereInput
  ) => DiscountRequestSubscriptionPayloadSubscription;
  event: (
    where?: EventSubscriptionWhereInput
  ) => EventSubscriptionPayloadSubscription;
  item: (
    where?: ItemSubscriptionWhereInput
  ) => ItemSubscriptionPayloadSubscription;
  lesson: (
    where?: LessonSubscriptionWhereInput
  ) => LessonSubscriptionPayloadSubscription;
  news: (
    where?: NewsSubscriptionWhereInput
  ) => NewsSubscriptionPayloadSubscription;
  officialDocument: (
    where?: OfficialDocumentSubscriptionWhereInput
  ) => OfficialDocumentSubscriptionPayloadSubscription;
  operatingPeriod: (
    where?: OperatingPeriodSubscriptionWhereInput
  ) => OperatingPeriodSubscriptionPayloadSubscription;
  order: (
    where?: OrderSubscriptionWhereInput
  ) => OrderSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  productCategory: (
    where?: ProductCategorySubscriptionWhereInput
  ) => ProductCategorySubscriptionPayloadSubscription;
  program: (
    where?: ProgramSubscriptionWhereInput
  ) => ProgramSubscriptionPayloadSubscription;
  role: (
    where?: RoleSubscriptionWhereInput
  ) => RoleSubscriptionPayloadSubscription;
  session: (
    where?: SessionSubscriptionWhereInput
  ) => SessionSubscriptionPayloadSubscription;
  socialLink: (
    where?: SocialLinkSubscriptionWhereInput
  ) => SocialLinkSubscriptionPayloadSubscription;
  socialNetwork: (
    where?: SocialNetworkSubscriptionWhereInput
  ) => SocialNetworkSubscriptionPayloadSubscription;
  space: (
    where?: SpaceSubscriptionWhereInput
  ) => SpaceSubscriptionPayloadSubscription;
  subject: (
    where?: SubjectSubscriptionWhereInput
  ) => SubjectSubscriptionPayloadSubscription;
  transaction: (
    where?: TransactionSubscriptionWhereInput
  ) => TransactionSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  venue: (
    where?: VenueSubscriptionWhereInput
  ) => VenueSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type DiscountRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "applied_ASC"
  | "applied_DESC"
  | "approved_ASC"
  | "approved_DESC";

export type TxType = "SALE" | "PURCHASE" | "RECEIPT" | "PAYMENT";

export type LessonOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type VenueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "address_ASC"
  | "address_DESC"
  | "placeID_ASC"
  | "placeID_DESC"
  | "latitude_ASC"
  | "latitude_DESC"
  | "longitude_ASC"
  | "longitude_DESC";

export type AppNodeStatus = "DRAFT" | "PUBLISHED" | "DEFERED";

export type ProgramOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "shortName_ASC"
  | "shortName_DESC"
  | "description_ASC"
  | "description_DESC";

export type BranchOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "shortName_ASC"
  | "shortName_DESC"
  | "description_ASC"
  | "description_DESC";

export type UserGroup = "STUDENT" | "STAFF" | "PUBLIC";

export type SubjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "shortName_ASC"
  | "shortName_DESC"
  | "description_ASC"
  | "description_DESC";

export type OperatingPeriodOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "yearStart_ASC"
  | "yearStart_DESC"
  | "yearEnd_ASC"
  | "yearEnd_DESC";

export type SessionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "closedAt_ASC"
  | "closedAt_DESC";

export type TransactionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "reference_ASC"
  | "reference_DESC"
  | "amount_ASC"
  | "amount_DESC";

export type SpaceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type ItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "orderPrice_ASC"
  | "orderPrice_DESC";

export type EventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "subtitle_ASC"
  | "subtitle_DESC"
  | "organizer_ASC"
  | "organizer_DESC"
  | "body_ASC"
  | "body_DESC"
  | "imageURL_ASC"
  | "imageURL_DESC"
  | "date_ASC"
  | "date_DESC"
  | "access_ASC"
  | "access_DESC"
  | "accessPoint_ASC"
  | "accessPoint_DESC"
  | "target_ASC"
  | "target_DESC"
  | "status_ASC"
  | "status_DESC";

export type DiscountOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "code_ASC"
  | "code_DESC"
  | "unitPrice_ASC"
  | "unitPrice_DESC"
  | "requirements_ASC"
  | "requirements_DESC";

export type NewsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "subtitle_ASC"
  | "subtitle_DESC"
  | "body_ASC"
  | "body_DESC"
  | "imageURL_ASC"
  | "imageURL_DESC"
  | "expiration_ASC"
  | "expiration_DESC"
  | "category_ASC"
  | "category_DESC"
  | "featured_ASC"
  | "featured_DESC"
  | "target_ASC"
  | "target_DESC"
  | "status_ASC"
  | "status_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type SocialLinkOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "link_ASC"
  | "link_DESC";

export type ProductCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type OfficialDocumentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "number_ASC"
  | "number_DESC"
  | "type_ASC"
  | "type_DESC"
  | "other_ASC"
  | "other_DESC"
  | "expiration_ASC"
  | "expiration_DESC";

export type DepartmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type RoleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "firstname_ASC"
  | "firstname_DESC"
  | "lastname_ASC"
  | "lastname_DESC"
  | "email_ASC"
  | "email_DESC"
  | "emailVerified_ASC"
  | "emailVerified_DESC"
  | "password_ASC"
  | "password_DESC"
  | "group_ASC"
  | "group_DESC"
  | "groupRequest_ASC"
  | "groupRequest_DESC"
  | "isAdmin_ASC"
  | "isAdmin_DESC"
  | "avatar_ASC"
  | "avatar_DESC"
  | "metadata_ASC"
  | "metadata_DESC";

export type AddressOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "address1_ASC"
  | "address1_DESC"
  | "address2_ASC"
  | "address2_DESC"
  | "city_ASC"
  | "city_DESC"
  | "region_ASC"
  | "region_DESC"
  | "country_ASC"
  | "country_DESC"
  | "code_ASC"
  | "code_DESC"
  | "primary_ASC"
  | "primary_DESC";

export type DeviceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "countryCode_ASC"
  | "countryCode_DESC"
  | "number_ASC"
  | "number_DESC"
  | "type_ASC"
  | "type_DESC"
  | "notificationsDevice_ASC"
  | "notificationsDevice_DESC"
  | "notificationsPermission_ASC"
  | "notificationsPermission_DESC"
  | "verified_ASC"
  | "verified_DESC";

export type DeviceType = "PHONE" | "TABLET" | "OTHER";

export type OrderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "reference_ASC"
  | "reference_DESC"
  | "metadata_ASC"
  | "metadata_DESC"
  | "paymentSettled_ASC"
  | "paymentSettled_DESC"
  | "paymentDue_ASC"
  | "paymentDue_DESC"
  | "vatRate_ASC"
  | "vatRate_DESC"
  | "total_ASC"
  | "total_DESC";

export type SocialNetworkOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "baseURL_ASC"
  | "baseURL_DESC"
  | "ownURL_ASC"
  | "ownURL_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "content_ASC"
  | "content_DESC"
  | "unitPrice_ASC"
  | "unitPrice_DESC";

export type OfficialDocumentType =
  | "NATIONALID"
  | "PASSPORT"
  | "SOCIALSECURITY"
  | "DRIVINGLICENSE"
  | "OTHER";

export interface LessonUpdateWithWhereUniqueWithoutAvailableTeachersInput {
  where: LessonWhereUniqueInput;
  data: LessonUpdateWithoutAvailableTeachersDataInput;
}

export type AddressWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SpaceUpdateWithoutSessionsDataInput {
  name?: Maybe<String>;
  venue?: Maybe<VenueUpdateOneRequiredWithoutSpacesInput>;
  events?: Maybe<EventUpdateManyWithoutPlaceInput>;
}

export interface ProductWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  unitPrice?: Maybe<Float>;
  unitPrice_not?: Maybe<Float>;
  unitPrice_in?: Maybe<Float[] | Float>;
  unitPrice_not_in?: Maybe<Float[] | Float>;
  unitPrice_lt?: Maybe<Float>;
  unitPrice_lte?: Maybe<Float>;
  unitPrice_gt?: Maybe<Float>;
  unitPrice_gte?: Maybe<Float>;
  category?: Maybe<ProductCategoryWhereInput>;
  discounts_every?: Maybe<DiscountWhereInput>;
  discounts_some?: Maybe<DiscountWhereInput>;
  discounts_none?: Maybe<DiscountWhereInput>;
  orders_every?: Maybe<ItemWhereInput>;
  orders_some?: Maybe<ItemWhereInput>;
  orders_none?: Maybe<ItemWhereInput>;
  AND?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  OR?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  NOT?: Maybe<ProductWhereInput[] | ProductWhereInput>;
}

export interface EventUpdateManyWithoutPlaceInput {
  create?: Maybe<EventCreateWithoutPlaceInput[] | EventCreateWithoutPlaceInput>;
  delete?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  set?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  disconnect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  update?: Maybe<
    | EventUpdateWithWhereUniqueWithoutPlaceInput[]
    | EventUpdateWithWhereUniqueWithoutPlaceInput
  >;
  upsert?: Maybe<
    | EventUpsertWithWhereUniqueWithoutPlaceInput[]
    | EventUpsertWithWhereUniqueWithoutPlaceInput
  >;
  deleteMany?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  updateMany?: Maybe<
    EventUpdateManyWithWhereNestedInput[] | EventUpdateManyWithWhereNestedInput
  >;
}

export interface ItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  order?: Maybe<OrderWhereInput>;
  product?: Maybe<ProductWhereInput>;
  discount?: Maybe<DiscountWhereInput>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  orderPrice?: Maybe<Float>;
  orderPrice_not?: Maybe<Float>;
  orderPrice_in?: Maybe<Float[] | Float>;
  orderPrice_not_in?: Maybe<Float[] | Float>;
  orderPrice_lt?: Maybe<Float>;
  orderPrice_lte?: Maybe<Float>;
  orderPrice_gt?: Maybe<Float>;
  orderPrice_gte?: Maybe<Float>;
  AND?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  OR?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  NOT?: Maybe<ItemWhereInput[] | ItemWhereInput>;
}

export interface EventUpdateWithWhereUniqueWithoutPlaceInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutPlaceDataInput;
}

export interface TransactionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  type?: Maybe<TxType>;
  type_not?: Maybe<TxType>;
  type_in?: Maybe<TxType[] | TxType>;
  type_not_in?: Maybe<TxType[] | TxType>;
  reference?: Maybe<String>;
  reference_not?: Maybe<String>;
  reference_in?: Maybe<String[] | String>;
  reference_not_in?: Maybe<String[] | String>;
  reference_lt?: Maybe<String>;
  reference_lte?: Maybe<String>;
  reference_gt?: Maybe<String>;
  reference_gte?: Maybe<String>;
  reference_contains?: Maybe<String>;
  reference_not_contains?: Maybe<String>;
  reference_starts_with?: Maybe<String>;
  reference_not_starts_with?: Maybe<String>;
  reference_ends_with?: Maybe<String>;
  reference_not_ends_with?: Maybe<String>;
  order?: Maybe<OrderWhereInput>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  AND?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
  OR?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
  NOT?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
}

export interface EventUpdateWithoutPlaceDataInput {
  author?: Maybe<UserUpdateOneRequiredWithoutEventsInput>;
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  organizer?: Maybe<String>;
  body?: Maybe<String>;
  imageURL?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  access?: Maybe<String>;
  accessPoint?: Maybe<String>;
  target?: Maybe<UserGroup>;
  status?: Maybe<AppNodeStatus>;
}

export interface DiscountRequestWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  discount?: Maybe<DiscountWhereInput>;
  user?: Maybe<UserWhereInput>;
  applied?: Maybe<Boolean>;
  applied_not?: Maybe<Boolean>;
  approved?: Maybe<Boolean>;
  approved_not?: Maybe<Boolean>;
  AND?: Maybe<DiscountRequestWhereInput[] | DiscountRequestWhereInput>;
  OR?: Maybe<DiscountRequestWhereInput[] | DiscountRequestWhereInput>;
  NOT?: Maybe<DiscountRequestWhereInput[] | DiscountRequestWhereInput>;
}

export interface SocialLinkUpdateWithWhereUniqueWithoutOwnerInput {
  where: SocialLinkWhereUniqueInput;
  data: SocialLinkUpdateWithoutOwnerDataInput;
}

export interface ProductCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  content?: Maybe<String>;
  unitPrice: Float;
  category: ProductCategoryCreateOneWithoutProductsInput;
  imageURLs?: Maybe<ProductCreateimageURLsInput>;
  discounts?: Maybe<DiscountCreateManyWithoutProductInput>;
  orders?: Maybe<ItemCreateManyWithoutProductInput>;
}

export interface SocialLinkUpdateWithoutOwnerDataInput {
  link?: Maybe<String>;
  socialNetwork?: Maybe<SocialNetworkUpdateOneRequiredWithoutUserLinksInput>;
}

export interface UserUpdateOneRequiredWithoutEventsInput {
  create?: Maybe<UserCreateWithoutEventsInput>;
  update?: Maybe<UserUpdateWithoutEventsDataInput>;
  upsert?: Maybe<UserUpsertWithoutEventsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface SocialNetworkUpdateOneRequiredWithoutUserLinksInput {
  create?: Maybe<SocialNetworkCreateWithoutUserLinksInput>;
  update?: Maybe<SocialNetworkUpdateWithoutUserLinksDataInput>;
  upsert?: Maybe<SocialNetworkUpsertWithoutUserLinksInput>;
  connect?: Maybe<SocialNetworkWhereUniqueInput>;
}

export interface VenueSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VenueWhereInput>;
  AND?: Maybe<VenueSubscriptionWhereInput[] | VenueSubscriptionWhereInput>;
  OR?: Maybe<VenueSubscriptionWhereInput[] | VenueSubscriptionWhereInput>;
  NOT?: Maybe<VenueSubscriptionWhereInput[] | VenueSubscriptionWhereInput>;
}

export interface SocialNetworkUpdateWithoutUserLinksDataInput {
  name?: Maybe<String>;
  baseURL?: Maybe<String>;
  ownURL?: Maybe<String>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface SocialNetworkUpsertWithoutUserLinksInput {
  update: SocialNetworkUpdateWithoutUserLinksDataInput;
  create: SocialNetworkCreateWithoutUserLinksInput;
}

export interface TransactionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TransactionWhereInput>;
  AND?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
  OR?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
}

export interface SocialLinkUpsertWithWhereUniqueWithoutOwnerInput {
  where: SocialLinkWhereUniqueInput;
  update: SocialLinkUpdateWithoutOwnerDataInput;
  create: SocialLinkCreateWithoutOwnerInput;
}

export interface SpaceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SpaceWhereInput>;
  AND?: Maybe<SpaceSubscriptionWhereInput[] | SpaceSubscriptionWhereInput>;
  OR?: Maybe<SpaceSubscriptionWhereInput[] | SpaceSubscriptionWhereInput>;
  NOT?: Maybe<SpaceSubscriptionWhereInput[] | SpaceSubscriptionWhereInput>;
}

export interface SocialLinkScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  AND?: Maybe<SocialLinkScalarWhereInput[] | SocialLinkScalarWhereInput>;
  OR?: Maybe<SocialLinkScalarWhereInput[] | SocialLinkScalarWhereInput>;
  NOT?: Maybe<SocialLinkScalarWhereInput[] | SocialLinkScalarWhereInput>;
}

export interface LessonWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  subjects_every?: Maybe<SubjectWhereInput>;
  subjects_some?: Maybe<SubjectWhereInput>;
  subjects_none?: Maybe<SubjectWhereInput>;
  period?: Maybe<OperatingPeriodWhereInput>;
  sessions_every?: Maybe<SessionWhereInput>;
  sessions_some?: Maybe<SessionWhereInput>;
  sessions_none?: Maybe<SessionWhereInput>;
  manager?: Maybe<UserWhereInput>;
  availableTeachers_every?: Maybe<UserWhereInput>;
  availableTeachers_some?: Maybe<UserWhereInput>;
  availableTeachers_none?: Maybe<UserWhereInput>;
  AND?: Maybe<LessonWhereInput[] | LessonWhereInput>;
  OR?: Maybe<LessonWhereInput[] | LessonWhereInput>;
  NOT?: Maybe<LessonWhereInput[] | LessonWhereInput>;
}

export interface SocialLinkUpdateManyWithWhereNestedInput {
  where: SocialLinkScalarWhereInput;
  data: SocialLinkUpdateManyDataInput;
}

export interface SessionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  lesson?: Maybe<LessonWhereInput>;
  closedAt?: Maybe<DateTimeInput>;
  closedAt_not?: Maybe<DateTimeInput>;
  closedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  closedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  closedAt_lt?: Maybe<DateTimeInput>;
  closedAt_lte?: Maybe<DateTimeInput>;
  closedAt_gt?: Maybe<DateTimeInput>;
  closedAt_gte?: Maybe<DateTimeInput>;
  by?: Maybe<UserWhereInput>;
  at?: Maybe<SpaceWhereInput>;
  AND?: Maybe<SessionWhereInput[] | SessionWhereInput>;
  OR?: Maybe<SessionWhereInput[] | SessionWhereInput>;
  NOT?: Maybe<SessionWhereInput[] | SessionWhereInput>;
}

export interface SocialLinkUpdateManyDataInput {
  link?: Maybe<String>;
}

export interface RoleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RoleWhereInput>;
  AND?: Maybe<RoleSubscriptionWhereInput[] | RoleSubscriptionWhereInput>;
  OR?: Maybe<RoleSubscriptionWhereInput[] | RoleSubscriptionWhereInput>;
  NOT?: Maybe<RoleSubscriptionWhereInput[] | RoleSubscriptionWhereInput>;
}

export interface DepartmentUpdateOneWithoutMembersInput {
  create?: Maybe<DepartmentCreateWithoutMembersInput>;
  update?: Maybe<DepartmentUpdateWithoutMembersDataInput>;
  upsert?: Maybe<DepartmentUpsertWithoutMembersInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface ProductCategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductCategoryWhereInput>;
  AND?: Maybe<
    | ProductCategorySubscriptionWhereInput[]
    | ProductCategorySubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProductCategorySubscriptionWhereInput[]
    | ProductCategorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProductCategorySubscriptionWhereInput[]
    | ProductCategorySubscriptionWhereInput
  >;
}

export interface DepartmentUpdateWithoutMembersDataInput {
  name?: Maybe<String>;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  OR?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  NOT?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
}

export interface DepartmentUpsertWithoutMembersInput {
  update: DepartmentUpdateWithoutMembersDataInput;
  create: DepartmentCreateWithoutMembersInput;
}

export interface SpaceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  venue?: Maybe<VenueWhereInput>;
  events_every?: Maybe<EventWhereInput>;
  events_some?: Maybe<EventWhereInput>;
  events_none?: Maybe<EventWhereInput>;
  sessions_every?: Maybe<SessionWhereInput>;
  sessions_some?: Maybe<SessionWhereInput>;
  sessions_none?: Maybe<SessionWhereInput>;
  AND?: Maybe<SpaceWhereInput[] | SpaceWhereInput>;
  OR?: Maybe<SpaceWhereInput[] | SpaceWhereInput>;
  NOT?: Maybe<SpaceWhereInput[] | SpaceWhereInput>;
}

export interface NewsUpdateManyWithoutAuthorInput {
  create?: Maybe<NewsCreateWithoutAuthorInput[] | NewsCreateWithoutAuthorInput>;
  delete?: Maybe<NewsWhereUniqueInput[] | NewsWhereUniqueInput>;
  connect?: Maybe<NewsWhereUniqueInput[] | NewsWhereUniqueInput>;
  set?: Maybe<NewsWhereUniqueInput[] | NewsWhereUniqueInput>;
  disconnect?: Maybe<NewsWhereUniqueInput[] | NewsWhereUniqueInput>;
  update?: Maybe<
    | NewsUpdateWithWhereUniqueWithoutAuthorInput[]
    | NewsUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | NewsUpsertWithWhereUniqueWithoutAuthorInput[]
    | NewsUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<NewsScalarWhereInput[] | NewsScalarWhereInput>;
  updateMany?: Maybe<
    NewsUpdateManyWithWhereNestedInput[] | NewsUpdateManyWithWhereNestedInput
  >;
}

export interface OfficialDocumentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OfficialDocumentWhereInput>;
  AND?: Maybe<
    | OfficialDocumentSubscriptionWhereInput[]
    | OfficialDocumentSubscriptionWhereInput
  >;
  OR?: Maybe<
    | OfficialDocumentSubscriptionWhereInput[]
    | OfficialDocumentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | OfficialDocumentSubscriptionWhereInput[]
    | OfficialDocumentSubscriptionWhereInput
  >;
}

export interface NewsUpdateWithWhereUniqueWithoutAuthorInput {
  where: NewsWhereUniqueInput;
  data: NewsUpdateWithoutAuthorDataInput;
}

export interface EventWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  author?: Maybe<UserWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  subtitle?: Maybe<String>;
  subtitle_not?: Maybe<String>;
  subtitle_in?: Maybe<String[] | String>;
  subtitle_not_in?: Maybe<String[] | String>;
  subtitle_lt?: Maybe<String>;
  subtitle_lte?: Maybe<String>;
  subtitle_gt?: Maybe<String>;
  subtitle_gte?: Maybe<String>;
  subtitle_contains?: Maybe<String>;
  subtitle_not_contains?: Maybe<String>;
  subtitle_starts_with?: Maybe<String>;
  subtitle_not_starts_with?: Maybe<String>;
  subtitle_ends_with?: Maybe<String>;
  subtitle_not_ends_with?: Maybe<String>;
  organizer?: Maybe<String>;
  organizer_not?: Maybe<String>;
  organizer_in?: Maybe<String[] | String>;
  organizer_not_in?: Maybe<String[] | String>;
  organizer_lt?: Maybe<String>;
  organizer_lte?: Maybe<String>;
  organizer_gt?: Maybe<String>;
  organizer_gte?: Maybe<String>;
  organizer_contains?: Maybe<String>;
  organizer_not_contains?: Maybe<String>;
  organizer_starts_with?: Maybe<String>;
  organizer_not_starts_with?: Maybe<String>;
  organizer_ends_with?: Maybe<String>;
  organizer_not_ends_with?: Maybe<String>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  imageURL?: Maybe<String>;
  imageURL_not?: Maybe<String>;
  imageURL_in?: Maybe<String[] | String>;
  imageURL_not_in?: Maybe<String[] | String>;
  imageURL_lt?: Maybe<String>;
  imageURL_lte?: Maybe<String>;
  imageURL_gt?: Maybe<String>;
  imageURL_gte?: Maybe<String>;
  imageURL_contains?: Maybe<String>;
  imageURL_not_contains?: Maybe<String>;
  imageURL_starts_with?: Maybe<String>;
  imageURL_not_starts_with?: Maybe<String>;
  imageURL_ends_with?: Maybe<String>;
  imageURL_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  access?: Maybe<String>;
  access_not?: Maybe<String>;
  access_in?: Maybe<String[] | String>;
  access_not_in?: Maybe<String[] | String>;
  access_lt?: Maybe<String>;
  access_lte?: Maybe<String>;
  access_gt?: Maybe<String>;
  access_gte?: Maybe<String>;
  access_contains?: Maybe<String>;
  access_not_contains?: Maybe<String>;
  access_starts_with?: Maybe<String>;
  access_not_starts_with?: Maybe<String>;
  access_ends_with?: Maybe<String>;
  access_not_ends_with?: Maybe<String>;
  accessPoint?: Maybe<String>;
  accessPoint_not?: Maybe<String>;
  accessPoint_in?: Maybe<String[] | String>;
  accessPoint_not_in?: Maybe<String[] | String>;
  accessPoint_lt?: Maybe<String>;
  accessPoint_lte?: Maybe<String>;
  accessPoint_gt?: Maybe<String>;
  accessPoint_gte?: Maybe<String>;
  accessPoint_contains?: Maybe<String>;
  accessPoint_not_contains?: Maybe<String>;
  accessPoint_starts_with?: Maybe<String>;
  accessPoint_not_starts_with?: Maybe<String>;
  accessPoint_ends_with?: Maybe<String>;
  accessPoint_not_ends_with?: Maybe<String>;
  target?: Maybe<UserGroup>;
  target_not?: Maybe<UserGroup>;
  target_in?: Maybe<UserGroup[] | UserGroup>;
  target_not_in?: Maybe<UserGroup[] | UserGroup>;
  status?: Maybe<AppNodeStatus>;
  status_not?: Maybe<AppNodeStatus>;
  status_in?: Maybe<AppNodeStatus[] | AppNodeStatus>;
  status_not_in?: Maybe<AppNodeStatus[] | AppNodeStatus>;
  place?: Maybe<SpaceWhereInput>;
  AND?: Maybe<EventWhereInput[] | EventWhereInput>;
  OR?: Maybe<EventWhereInput[] | EventWhereInput>;
  NOT?: Maybe<EventWhereInput[] | EventWhereInput>;
}

export interface NewsUpdateWithoutAuthorDataInput {
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  body?: Maybe<String>;
  imageURL?: Maybe<String>;
  expiration?: Maybe<DateTimeInput>;
  category?: Maybe<String>;
  featured?: Maybe<Boolean>;
  target?: Maybe<UserGroup>;
  status?: Maybe<AppNodeStatus>;
}

export interface NewsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  author?: Maybe<UserWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  subtitle?: Maybe<String>;
  subtitle_not?: Maybe<String>;
  subtitle_in?: Maybe<String[] | String>;
  subtitle_not_in?: Maybe<String[] | String>;
  subtitle_lt?: Maybe<String>;
  subtitle_lte?: Maybe<String>;
  subtitle_gt?: Maybe<String>;
  subtitle_gte?: Maybe<String>;
  subtitle_contains?: Maybe<String>;
  subtitle_not_contains?: Maybe<String>;
  subtitle_starts_with?: Maybe<String>;
  subtitle_not_starts_with?: Maybe<String>;
  subtitle_ends_with?: Maybe<String>;
  subtitle_not_ends_with?: Maybe<String>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  imageURL?: Maybe<String>;
  imageURL_not?: Maybe<String>;
  imageURL_in?: Maybe<String[] | String>;
  imageURL_not_in?: Maybe<String[] | String>;
  imageURL_lt?: Maybe<String>;
  imageURL_lte?: Maybe<String>;
  imageURL_gt?: Maybe<String>;
  imageURL_gte?: Maybe<String>;
  imageURL_contains?: Maybe<String>;
  imageURL_not_contains?: Maybe<String>;
  imageURL_starts_with?: Maybe<String>;
  imageURL_not_starts_with?: Maybe<String>;
  imageURL_ends_with?: Maybe<String>;
  imageURL_not_ends_with?: Maybe<String>;
  expiration?: Maybe<DateTimeInput>;
  expiration_not?: Maybe<DateTimeInput>;
  expiration_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_lt?: Maybe<DateTimeInput>;
  expiration_lte?: Maybe<DateTimeInput>;
  expiration_gt?: Maybe<DateTimeInput>;
  expiration_gte?: Maybe<DateTimeInput>;
  category?: Maybe<String>;
  category_not?: Maybe<String>;
  category_in?: Maybe<String[] | String>;
  category_not_in?: Maybe<String[] | String>;
  category_lt?: Maybe<String>;
  category_lte?: Maybe<String>;
  category_gt?: Maybe<String>;
  category_gte?: Maybe<String>;
  category_contains?: Maybe<String>;
  category_not_contains?: Maybe<String>;
  category_starts_with?: Maybe<String>;
  category_not_starts_with?: Maybe<String>;
  category_ends_with?: Maybe<String>;
  category_not_ends_with?: Maybe<String>;
  featured?: Maybe<Boolean>;
  featured_not?: Maybe<Boolean>;
  target?: Maybe<UserGroup>;
  target_not?: Maybe<UserGroup>;
  target_in?: Maybe<UserGroup[] | UserGroup>;
  target_not_in?: Maybe<UserGroup[] | UserGroup>;
  status?: Maybe<AppNodeStatus>;
  status_not?: Maybe<AppNodeStatus>;
  status_in?: Maybe<AppNodeStatus[] | AppNodeStatus>;
  status_not_in?: Maybe<AppNodeStatus[] | AppNodeStatus>;
  AND?: Maybe<NewsWhereInput[] | NewsWhereInput>;
  OR?: Maybe<NewsWhereInput[] | NewsWhereInput>;
  NOT?: Maybe<NewsWhereInput[] | NewsWhereInput>;
}

export interface NewsUpsertWithWhereUniqueWithoutAuthorInput {
  where: NewsWhereUniqueInput;
  update: NewsUpdateWithoutAuthorDataInput;
  create: NewsCreateWithoutAuthorInput;
}

export interface ItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ItemWhereInput>;
  AND?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  OR?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  NOT?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
}

export interface NewsScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  subtitle?: Maybe<String>;
  subtitle_not?: Maybe<String>;
  subtitle_in?: Maybe<String[] | String>;
  subtitle_not_in?: Maybe<String[] | String>;
  subtitle_lt?: Maybe<String>;
  subtitle_lte?: Maybe<String>;
  subtitle_gt?: Maybe<String>;
  subtitle_gte?: Maybe<String>;
  subtitle_contains?: Maybe<String>;
  subtitle_not_contains?: Maybe<String>;
  subtitle_starts_with?: Maybe<String>;
  subtitle_not_starts_with?: Maybe<String>;
  subtitle_ends_with?: Maybe<String>;
  subtitle_not_ends_with?: Maybe<String>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  imageURL?: Maybe<String>;
  imageURL_not?: Maybe<String>;
  imageURL_in?: Maybe<String[] | String>;
  imageURL_not_in?: Maybe<String[] | String>;
  imageURL_lt?: Maybe<String>;
  imageURL_lte?: Maybe<String>;
  imageURL_gt?: Maybe<String>;
  imageURL_gte?: Maybe<String>;
  imageURL_contains?: Maybe<String>;
  imageURL_not_contains?: Maybe<String>;
  imageURL_starts_with?: Maybe<String>;
  imageURL_not_starts_with?: Maybe<String>;
  imageURL_ends_with?: Maybe<String>;
  imageURL_not_ends_with?: Maybe<String>;
  expiration?: Maybe<DateTimeInput>;
  expiration_not?: Maybe<DateTimeInput>;
  expiration_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_lt?: Maybe<DateTimeInput>;
  expiration_lte?: Maybe<DateTimeInput>;
  expiration_gt?: Maybe<DateTimeInput>;
  expiration_gte?: Maybe<DateTimeInput>;
  category?: Maybe<String>;
  category_not?: Maybe<String>;
  category_in?: Maybe<String[] | String>;
  category_not_in?: Maybe<String[] | String>;
  category_lt?: Maybe<String>;
  category_lte?: Maybe<String>;
  category_gt?: Maybe<String>;
  category_gte?: Maybe<String>;
  category_contains?: Maybe<String>;
  category_not_contains?: Maybe<String>;
  category_starts_with?: Maybe<String>;
  category_not_starts_with?: Maybe<String>;
  category_ends_with?: Maybe<String>;
  category_not_ends_with?: Maybe<String>;
  featured?: Maybe<Boolean>;
  featured_not?: Maybe<Boolean>;
  target?: Maybe<UserGroup>;
  target_not?: Maybe<UserGroup>;
  target_in?: Maybe<UserGroup[] | UserGroup>;
  target_not_in?: Maybe<UserGroup[] | UserGroup>;
  status?: Maybe<AppNodeStatus>;
  status_not?: Maybe<AppNodeStatus>;
  status_in?: Maybe<AppNodeStatus[] | AppNodeStatus>;
  status_not_in?: Maybe<AppNodeStatus[] | AppNodeStatus>;
  AND?: Maybe<NewsScalarWhereInput[] | NewsScalarWhereInput>;
  OR?: Maybe<NewsScalarWhereInput[] | NewsScalarWhereInput>;
  NOT?: Maybe<NewsScalarWhereInput[] | NewsScalarWhereInput>;
}

export interface DiscountRequestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DiscountRequestWhereInput>;
  AND?: Maybe<
    | DiscountRequestSubscriptionWhereInput[]
    | DiscountRequestSubscriptionWhereInput
  >;
  OR?: Maybe<
    | DiscountRequestSubscriptionWhereInput[]
    | DiscountRequestSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | DiscountRequestSubscriptionWhereInput[]
    | DiscountRequestSubscriptionWhereInput
  >;
}

export interface NewsUpdateManyWithWhereNestedInput {
  where: NewsScalarWhereInput;
  data: NewsUpdateManyDataInput;
}

export interface SocialNetworkWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  baseURL?: Maybe<String>;
  baseURL_not?: Maybe<String>;
  baseURL_in?: Maybe<String[] | String>;
  baseURL_not_in?: Maybe<String[] | String>;
  baseURL_lt?: Maybe<String>;
  baseURL_lte?: Maybe<String>;
  baseURL_gt?: Maybe<String>;
  baseURL_gte?: Maybe<String>;
  baseURL_contains?: Maybe<String>;
  baseURL_not_contains?: Maybe<String>;
  baseURL_starts_with?: Maybe<String>;
  baseURL_not_starts_with?: Maybe<String>;
  baseURL_ends_with?: Maybe<String>;
  baseURL_not_ends_with?: Maybe<String>;
  ownURL?: Maybe<String>;
  ownURL_not?: Maybe<String>;
  ownURL_in?: Maybe<String[] | String>;
  ownURL_not_in?: Maybe<String[] | String>;
  ownURL_lt?: Maybe<String>;
  ownURL_lte?: Maybe<String>;
  ownURL_gt?: Maybe<String>;
  ownURL_gte?: Maybe<String>;
  ownURL_contains?: Maybe<String>;
  ownURL_not_contains?: Maybe<String>;
  ownURL_starts_with?: Maybe<String>;
  ownURL_not_starts_with?: Maybe<String>;
  ownURL_ends_with?: Maybe<String>;
  ownURL_not_ends_with?: Maybe<String>;
  userLinks_every?: Maybe<SocialLinkWhereInput>;
  userLinks_some?: Maybe<SocialLinkWhereInput>;
  userLinks_none?: Maybe<SocialLinkWhereInput>;
  AND?: Maybe<SocialNetworkWhereInput[] | SocialNetworkWhereInput>;
  OR?: Maybe<SocialNetworkWhereInput[] | SocialNetworkWhereInput>;
  NOT?: Maybe<SocialNetworkWhereInput[] | SocialNetworkWhereInput>;
}

export interface NewsUpdateManyDataInput {
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  body?: Maybe<String>;
  imageURL?: Maybe<String>;
  expiration?: Maybe<DateTimeInput>;
  category?: Maybe<String>;
  featured?: Maybe<Boolean>;
  target?: Maybe<UserGroup>;
  status?: Maybe<AppNodeStatus>;
}

export interface OfficialDocumentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  number?: Maybe<String>;
  number_not?: Maybe<String>;
  number_in?: Maybe<String[] | String>;
  number_not_in?: Maybe<String[] | String>;
  number_lt?: Maybe<String>;
  number_lte?: Maybe<String>;
  number_gt?: Maybe<String>;
  number_gte?: Maybe<String>;
  number_contains?: Maybe<String>;
  number_not_contains?: Maybe<String>;
  number_starts_with?: Maybe<String>;
  number_not_starts_with?: Maybe<String>;
  number_ends_with?: Maybe<String>;
  number_not_ends_with?: Maybe<String>;
  type?: Maybe<OfficialDocumentType>;
  type_not?: Maybe<OfficialDocumentType>;
  type_in?: Maybe<OfficialDocumentType[] | OfficialDocumentType>;
  type_not_in?: Maybe<OfficialDocumentType[] | OfficialDocumentType>;
  other?: Maybe<String>;
  other_not?: Maybe<String>;
  other_in?: Maybe<String[] | String>;
  other_not_in?: Maybe<String[] | String>;
  other_lt?: Maybe<String>;
  other_lte?: Maybe<String>;
  other_gt?: Maybe<String>;
  other_gte?: Maybe<String>;
  other_contains?: Maybe<String>;
  other_not_contains?: Maybe<String>;
  other_starts_with?: Maybe<String>;
  other_not_starts_with?: Maybe<String>;
  other_ends_with?: Maybe<String>;
  other_not_ends_with?: Maybe<String>;
  expiration?: Maybe<DateTimeInput>;
  expiration_not?: Maybe<DateTimeInput>;
  expiration_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_lt?: Maybe<DateTimeInput>;
  expiration_lte?: Maybe<DateTimeInput>;
  expiration_gt?: Maybe<DateTimeInput>;
  expiration_gte?: Maybe<DateTimeInput>;
  owner?: Maybe<UserWhereInput>;
  AND?: Maybe<OfficialDocumentWhereInput[] | OfficialDocumentWhereInput>;
  OR?: Maybe<OfficialDocumentWhereInput[] | OfficialDocumentWhereInput>;
  NOT?: Maybe<OfficialDocumentWhereInput[] | OfficialDocumentWhereInput>;
}

export interface EventUpdateManyWithoutAuthorInput {
  create?: Maybe<
    EventCreateWithoutAuthorInput[] | EventCreateWithoutAuthorInput
  >;
  delete?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  set?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  disconnect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  update?: Maybe<
    | EventUpdateWithWhereUniqueWithoutAuthorInput[]
    | EventUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | EventUpsertWithWhereUniqueWithoutAuthorInput[]
    | EventUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  updateMany?: Maybe<
    EventUpdateManyWithWhereNestedInput[] | EventUpdateManyWithWhereNestedInput
  >;
}

export interface DepartmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DepartmentWhereInput>;
  AND?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
}

export interface EventUpdateWithWhereUniqueWithoutAuthorInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutAuthorDataInput;
}

export interface BranchSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BranchWhereInput>;
  AND?: Maybe<BranchSubscriptionWhereInput[] | BranchSubscriptionWhereInput>;
  OR?: Maybe<BranchSubscriptionWhereInput[] | BranchSubscriptionWhereInput>;
  NOT?: Maybe<BranchSubscriptionWhereInput[] | BranchSubscriptionWhereInput>;
}

export interface EventUpdateWithoutAuthorDataInput {
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  organizer?: Maybe<String>;
  body?: Maybe<String>;
  imageURL?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  access?: Maybe<String>;
  accessPoint?: Maybe<String>;
  target?: Maybe<UserGroup>;
  status?: Maybe<AppNodeStatus>;
  place?: Maybe<SpaceUpdateOneRequiredWithoutEventsInput>;
}

export interface VenueUpdateManyMutationInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  placeID?: Maybe<String>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
}

export interface SpaceUpdateOneRequiredWithoutEventsInput {
  create?: Maybe<SpaceCreateWithoutEventsInput>;
  update?: Maybe<SpaceUpdateWithoutEventsDataInput>;
  upsert?: Maybe<SpaceUpsertWithoutEventsInput>;
  connect?: Maybe<SpaceWhereUniqueInput>;
}

export interface SpaceUpdateManyWithWhereNestedInput {
  where: SpaceScalarWhereInput;
  data: SpaceUpdateManyDataInput;
}

export interface SpaceUpdateWithoutEventsDataInput {
  name?: Maybe<String>;
  venue?: Maybe<VenueUpdateOneRequiredWithoutSpacesInput>;
  sessions?: Maybe<SessionUpdateManyWithoutAtInput>;
}

export interface SpaceScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<SpaceScalarWhereInput[] | SpaceScalarWhereInput>;
  OR?: Maybe<SpaceScalarWhereInput[] | SpaceScalarWhereInput>;
  NOT?: Maybe<SpaceScalarWhereInput[] | SpaceScalarWhereInput>;
}

export interface VenueUpdateOneRequiredWithoutSpacesInput {
  create?: Maybe<VenueCreateWithoutSpacesInput>;
  update?: Maybe<VenueUpdateWithoutSpacesDataInput>;
  upsert?: Maybe<VenueUpsertWithoutSpacesInput>;
  connect?: Maybe<VenueWhereUniqueInput>;
}

export interface SpaceUpdateWithoutVenueDataInput {
  name?: Maybe<String>;
  events?: Maybe<EventUpdateManyWithoutPlaceInput>;
  sessions?: Maybe<SessionUpdateManyWithoutAtInput>;
}

export interface VenueUpdateWithoutSpacesDataInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  placeID?: Maybe<String>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
}

export interface AddressWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  owner?: Maybe<UserWhereInput>;
  address1?: Maybe<String>;
  address1_not?: Maybe<String>;
  address1_in?: Maybe<String[] | String>;
  address1_not_in?: Maybe<String[] | String>;
  address1_lt?: Maybe<String>;
  address1_lte?: Maybe<String>;
  address1_gt?: Maybe<String>;
  address1_gte?: Maybe<String>;
  address1_contains?: Maybe<String>;
  address1_not_contains?: Maybe<String>;
  address1_starts_with?: Maybe<String>;
  address1_not_starts_with?: Maybe<String>;
  address1_ends_with?: Maybe<String>;
  address1_not_ends_with?: Maybe<String>;
  address2?: Maybe<String>;
  address2_not?: Maybe<String>;
  address2_in?: Maybe<String[] | String>;
  address2_not_in?: Maybe<String[] | String>;
  address2_lt?: Maybe<String>;
  address2_lte?: Maybe<String>;
  address2_gt?: Maybe<String>;
  address2_gte?: Maybe<String>;
  address2_contains?: Maybe<String>;
  address2_not_contains?: Maybe<String>;
  address2_starts_with?: Maybe<String>;
  address2_not_starts_with?: Maybe<String>;
  address2_ends_with?: Maybe<String>;
  address2_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  region?: Maybe<String>;
  region_not?: Maybe<String>;
  region_in?: Maybe<String[] | String>;
  region_not_in?: Maybe<String[] | String>;
  region_lt?: Maybe<String>;
  region_lte?: Maybe<String>;
  region_gt?: Maybe<String>;
  region_gte?: Maybe<String>;
  region_contains?: Maybe<String>;
  region_not_contains?: Maybe<String>;
  region_starts_with?: Maybe<String>;
  region_not_starts_with?: Maybe<String>;
  region_ends_with?: Maybe<String>;
  region_not_ends_with?: Maybe<String>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  primary?: Maybe<Boolean>;
  primary_not?: Maybe<Boolean>;
  AND?: Maybe<AddressWhereInput[] | AddressWhereInput>;
  OR?: Maybe<AddressWhereInput[] | AddressWhereInput>;
  NOT?: Maybe<AddressWhereInput[] | AddressWhereInput>;
}

export interface VenueUpsertWithoutSpacesInput {
  update: VenueUpdateWithoutSpacesDataInput;
  create: VenueCreateWithoutSpacesInput;
}

export interface SpaceUpdateManyWithoutVenueInput {
  create?: Maybe<SpaceCreateWithoutVenueInput[] | SpaceCreateWithoutVenueInput>;
  delete?: Maybe<SpaceWhereUniqueInput[] | SpaceWhereUniqueInput>;
  connect?: Maybe<SpaceWhereUniqueInput[] | SpaceWhereUniqueInput>;
  set?: Maybe<SpaceWhereUniqueInput[] | SpaceWhereUniqueInput>;
  disconnect?: Maybe<SpaceWhereUniqueInput[] | SpaceWhereUniqueInput>;
  update?: Maybe<
    | SpaceUpdateWithWhereUniqueWithoutVenueInput[]
    | SpaceUpdateWithWhereUniqueWithoutVenueInput
  >;
  upsert?: Maybe<
    | SpaceUpsertWithWhereUniqueWithoutVenueInput[]
    | SpaceUpsertWithWhereUniqueWithoutVenueInput
  >;
  deleteMany?: Maybe<SpaceScalarWhereInput[] | SpaceScalarWhereInput>;
  updateMany?: Maybe<
    SpaceUpdateManyWithWhereNestedInput[] | SpaceUpdateManyWithWhereNestedInput
  >;
}

export interface SessionUpdateManyWithoutAtInput {
  create?: Maybe<SessionCreateWithoutAtInput[] | SessionCreateWithoutAtInput>;
  delete?: Maybe<SessionWhereUniqueInput[] | SessionWhereUniqueInput>;
  connect?: Maybe<SessionWhereUniqueInput[] | SessionWhereUniqueInput>;
  set?: Maybe<SessionWhereUniqueInput[] | SessionWhereUniqueInput>;
  disconnect?: Maybe<SessionWhereUniqueInput[] | SessionWhereUniqueInput>;
  update?: Maybe<
    | SessionUpdateWithWhereUniqueWithoutAtInput[]
    | SessionUpdateWithWhereUniqueWithoutAtInput
  >;
  upsert?: Maybe<
    | SessionUpsertWithWhereUniqueWithoutAtInput[]
    | SessionUpsertWithWhereUniqueWithoutAtInput
  >;
  deleteMany?: Maybe<SessionScalarWhereInput[] | SessionScalarWhereInput>;
  updateMany?: Maybe<
    | SessionUpdateManyWithWhereNestedInput[]
    | SessionUpdateManyWithWhereNestedInput
  >;
}

export type DeviceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SessionUpdateWithWhereUniqueWithoutAtInput {
  where: SessionWhereUniqueInput;
  data: SessionUpdateWithoutAtDataInput;
}

export interface SpaceCreateManyWithoutVenueInput {
  create?: Maybe<SpaceCreateWithoutVenueInput[] | SpaceCreateWithoutVenueInput>;
  connect?: Maybe<SpaceWhereUniqueInput[] | SpaceWhereUniqueInput>;
}

export interface SessionUpdateWithoutAtDataInput {
  lesson?: Maybe<LessonUpdateOneRequiredWithoutSessionsInput>;
  closedAt?: Maybe<DateTimeInput>;
  by?: Maybe<UserUpdateOneRequiredWithoutTeachedSessionsInput>;
}

export type DiscountWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LessonUpdateOneRequiredWithoutSessionsInput {
  create?: Maybe<LessonCreateWithoutSessionsInput>;
  update?: Maybe<LessonUpdateWithoutSessionsDataInput>;
  upsert?: Maybe<LessonUpsertWithoutSessionsInput>;
  connect?: Maybe<LessonWhereUniqueInput>;
}

export interface UserUpdateInput {
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  email?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  password?: Maybe<String>;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleUpdateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressUpdateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceUpdateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentUpdateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkUpdateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  newses?: Maybe<NewsUpdateManyWithoutAuthorInput>;
  events?: Maybe<EventUpdateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonUpdateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonUpdateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionUpdateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestUpdateManyWithoutUserInput>;
}

export interface LessonUpdateWithoutSessionsDataInput {
  name?: Maybe<String>;
  subjects?: Maybe<SubjectUpdateManyWithoutLessonInput>;
  period?: Maybe<OperatingPeriodUpdateOneRequiredWithoutLessonsInput>;
  manager?: Maybe<UserUpdateOneRequiredWithoutLessonsManagedInput>;
  availableTeachers?: Maybe<UserUpdateManyWithoutAvailableLessonsInput>;
}

export type DiscountRequestWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SubjectUpdateManyWithoutLessonInput {
  create?: Maybe<
    SubjectCreateWithoutLessonInput[] | SubjectCreateWithoutLessonInput
  >;
  delete?: Maybe<SubjectWhereUniqueInput[] | SubjectWhereUniqueInput>;
  connect?: Maybe<SubjectWhereUniqueInput[] | SubjectWhereUniqueInput>;
  set?: Maybe<SubjectWhereUniqueInput[] | SubjectWhereUniqueInput>;
  disconnect?: Maybe<SubjectWhereUniqueInput[] | SubjectWhereUniqueInput>;
  update?: Maybe<
    | SubjectUpdateWithWhereUniqueWithoutLessonInput[]
    | SubjectUpdateWithWhereUniqueWithoutLessonInput
  >;
  upsert?: Maybe<
    | SubjectUpsertWithWhereUniqueWithoutLessonInput[]
    | SubjectUpsertWithWhereUniqueWithoutLessonInput
  >;
  deleteMany?: Maybe<SubjectScalarWhereInput[] | SubjectScalarWhereInput>;
  updateMany?: Maybe<
    | SubjectUpdateManyWithWhereNestedInput[]
    | SubjectUpdateManyWithWhereNestedInput
  >;
}

export interface OrderUpdateWithoutTransactionsDataInput {
  customer?: Maybe<UserUpdateOneRequiredInput>;
  items?: Maybe<ItemUpdateManyWithoutOrderInput>;
  reference?: Maybe<String>;
  metadata?: Maybe<Json>;
  paymentSettled?: Maybe<Boolean>;
  paymentDue?: Maybe<DateTimeInput>;
  vatRate?: Maybe<Int>;
  total?: Maybe<Float>;
}

export interface SubjectUpdateWithWhereUniqueWithoutLessonInput {
  where: SubjectWhereUniqueInput;
  data: SubjectUpdateWithoutLessonDataInput;
}

export type EventWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SubjectUpdateWithoutLessonDataInput {
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  description?: Maybe<String>;
  branch?: Maybe<BranchUpdateOneRequiredWithoutSubjectsInput>;
}

export interface OrderCreateWithoutTransactionsInput {
  id?: Maybe<ID_Input>;
  customer: UserCreateOneInput;
  items?: Maybe<ItemCreateManyWithoutOrderInput>;
  reference: String;
  metadata?: Maybe<Json>;
  paymentSettled?: Maybe<Boolean>;
  paymentDue?: Maybe<DateTimeInput>;
  vatRate?: Maybe<Int>;
  total: Float;
}

export interface BranchUpdateOneRequiredWithoutSubjectsInput {
  create?: Maybe<BranchCreateWithoutSubjectsInput>;
  update?: Maybe<BranchUpdateWithoutSubjectsDataInput>;
  upsert?: Maybe<BranchUpsertWithoutSubjectsInput>;
  connect?: Maybe<BranchWhereUniqueInput>;
}

export type ItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BranchUpdateWithoutSubjectsDataInput {
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  description?: Maybe<String>;
  program?: Maybe<ProgramUpdateOneRequiredWithoutBranchesInput>;
}

export interface SubjectUpdateManyMutationInput {
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  description?: Maybe<String>;
}

export interface ProgramUpdateOneRequiredWithoutBranchesInput {
  create?: Maybe<ProgramCreateWithoutBranchesInput>;
  update?: Maybe<ProgramUpdateWithoutBranchesDataInput>;
  upsert?: Maybe<ProgramUpsertWithoutBranchesInput>;
  connect?: Maybe<ProgramWhereUniqueInput>;
}

export type LessonWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProgramUpdateWithoutBranchesDataInput {
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  description?: Maybe<String>;
}

export interface SpaceUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface ProgramUpsertWithoutBranchesInput {
  update: ProgramUpdateWithoutBranchesDataInput;
  create: ProgramCreateWithoutBranchesInput;
}

export type NewsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BranchUpsertWithoutSubjectsInput {
  update: BranchUpdateWithoutSubjectsDataInput;
  create: BranchCreateWithoutSubjectsInput;
}

export interface SocialNetworkUpdateManyMutationInput {
  name?: Maybe<String>;
  baseURL?: Maybe<String>;
  ownURL?: Maybe<String>;
}

export interface SubjectUpsertWithWhereUniqueWithoutLessonInput {
  where: SubjectWhereUniqueInput;
  update: SubjectUpdateWithoutLessonDataInput;
  create: SubjectCreateWithoutLessonInput;
}

export type OfficialDocumentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  number?: Maybe<String>;
}>;

export interface SubjectScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  shortName?: Maybe<String>;
  shortName_not?: Maybe<String>;
  shortName_in?: Maybe<String[] | String>;
  shortName_not_in?: Maybe<String[] | String>;
  shortName_lt?: Maybe<String>;
  shortName_lte?: Maybe<String>;
  shortName_gt?: Maybe<String>;
  shortName_gte?: Maybe<String>;
  shortName_contains?: Maybe<String>;
  shortName_not_contains?: Maybe<String>;
  shortName_starts_with?: Maybe<String>;
  shortName_not_starts_with?: Maybe<String>;
  shortName_ends_with?: Maybe<String>;
  shortName_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<SubjectScalarWhereInput[] | SubjectScalarWhereInput>;
  OR?: Maybe<SubjectScalarWhereInput[] | SubjectScalarWhereInput>;
  NOT?: Maybe<SubjectScalarWhereInput[] | SubjectScalarWhereInput>;
}

export interface SocialLinkUpdateWithWhereUniqueWithoutSocialNetworkInput {
  where: SocialLinkWhereUniqueInput;
  data: SocialLinkUpdateWithoutSocialNetworkDataInput;
}

export interface SubjectUpdateManyWithWhereNestedInput {
  where: SubjectScalarWhereInput;
  data: SubjectUpdateManyDataInput;
}

export type OperatingPeriodWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SubjectUpdateManyDataInput {
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  description?: Maybe<String>;
}

export interface SocialNetworkUpdateInput {
  name?: Maybe<String>;
  baseURL?: Maybe<String>;
  ownURL?: Maybe<String>;
  userLinks?: Maybe<SocialLinkUpdateManyWithoutSocialNetworkInput>;
}

export interface OperatingPeriodUpdateOneRequiredWithoutLessonsInput {
  create?: Maybe<OperatingPeriodCreateWithoutLessonsInput>;
  update?: Maybe<OperatingPeriodUpdateWithoutLessonsDataInput>;
  upsert?: Maybe<OperatingPeriodUpsertWithoutLessonsInput>;
  connect?: Maybe<OperatingPeriodWhereUniqueInput>;
}

export interface SocialLinkCreateManyWithoutSocialNetworkInput {
  create?: Maybe<
    | SocialLinkCreateWithoutSocialNetworkInput[]
    | SocialLinkCreateWithoutSocialNetworkInput
  >;
  connect?: Maybe<SocialLinkWhereUniqueInput[] | SocialLinkWhereUniqueInput>;
}

export interface OperatingPeriodUpdateWithoutLessonsDataInput {
  yearStart?: Maybe<Int>;
  yearEnd?: Maybe<Int>;
}

export interface RoleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  users_every?: Maybe<UserWhereInput>;
  users_some?: Maybe<UserWhereInput>;
  users_none?: Maybe<UserWhereInput>;
  AND?: Maybe<RoleWhereInput[] | RoleWhereInput>;
  OR?: Maybe<RoleWhereInput[] | RoleWhereInput>;
  NOT?: Maybe<RoleWhereInput[] | RoleWhereInput>;
}

export interface OperatingPeriodUpsertWithoutLessonsInput {
  update: OperatingPeriodUpdateWithoutLessonsDataInput;
  create: OperatingPeriodCreateWithoutLessonsInput;
}

export interface SocialLinkUpdateManyMutationInput {
  link?: Maybe<String>;
}

export interface UserUpdateOneRequiredWithoutLessonsManagedInput {
  create?: Maybe<UserCreateWithoutLessonsManagedInput>;
  update?: Maybe<UserUpdateWithoutLessonsManagedDataInput>;
  upsert?: Maybe<UserUpsertWithoutLessonsManagedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateWithoutLessonsManagedDataInput {
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  email?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  password?: Maybe<String>;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleUpdateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressUpdateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceUpdateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentUpdateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkUpdateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  newses?: Maybe<NewsUpdateManyWithoutAuthorInput>;
  events?: Maybe<EventUpdateManyWithoutAuthorInput>;
  availableLessons?: Maybe<LessonUpdateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionUpdateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestUpdateManyWithoutUserInput>;
}

export interface UserUpdateOneRequiredWithoutSocialNetworkLinksInput {
  create?: Maybe<UserCreateWithoutSocialNetworkLinksInput>;
  update?: Maybe<UserUpdateWithoutSocialNetworkLinksDataInput>;
  upsert?: Maybe<UserUpsertWithoutSocialNetworkLinksInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface AddressUpdateManyWithoutOwnerInput {
  create?: Maybe<
    AddressCreateWithoutOwnerInput[] | AddressCreateWithoutOwnerInput
  >;
  delete?: Maybe<AddressWhereUniqueInput[] | AddressWhereUniqueInput>;
  connect?: Maybe<AddressWhereUniqueInput[] | AddressWhereUniqueInput>;
  set?: Maybe<AddressWhereUniqueInput[] | AddressWhereUniqueInput>;
  disconnect?: Maybe<AddressWhereUniqueInput[] | AddressWhereUniqueInput>;
  update?: Maybe<
    | AddressUpdateWithWhereUniqueWithoutOwnerInput[]
    | AddressUpdateWithWhereUniqueWithoutOwnerInput
  >;
  upsert?: Maybe<
    | AddressUpsertWithWhereUniqueWithoutOwnerInput[]
    | AddressUpsertWithWhereUniqueWithoutOwnerInput
  >;
  deleteMany?: Maybe<AddressScalarWhereInput[] | AddressScalarWhereInput>;
  updateMany?: Maybe<
    | AddressUpdateManyWithWhereNestedInput[]
    | AddressUpdateManyWithWhereNestedInput
  >;
}

export type ProductCategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface AddressUpdateWithWhereUniqueWithoutOwnerInput {
  where: AddressWhereUniqueInput;
  data: AddressUpdateWithoutOwnerDataInput;
}

export interface UserCreateOneWithoutSocialNetworkLinksInput {
  create?: Maybe<UserCreateWithoutSocialNetworkLinksInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface AddressUpdateWithoutOwnerDataInput {
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  region?: Maybe<String>;
  country?: Maybe<String>;
  code?: Maybe<String>;
  primary?: Maybe<Boolean>;
}

export interface SessionUpdateManyMutationInput {
  closedAt?: Maybe<DateTimeInput>;
}

export interface AddressUpsertWithWhereUniqueWithoutOwnerInput {
  where: AddressWhereUniqueInput;
  update: AddressUpdateWithoutOwnerDataInput;
  create: AddressCreateWithoutOwnerInput;
}

export interface SessionUpdateInput {
  lesson?: Maybe<LessonUpdateOneRequiredWithoutSessionsInput>;
  closedAt?: Maybe<DateTimeInput>;
  by?: Maybe<UserUpdateOneRequiredWithoutTeachedSessionsInput>;
  at?: Maybe<SpaceUpdateOneRequiredWithoutSessionsInput>;
}

export interface AddressScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  address1?: Maybe<String>;
  address1_not?: Maybe<String>;
  address1_in?: Maybe<String[] | String>;
  address1_not_in?: Maybe<String[] | String>;
  address1_lt?: Maybe<String>;
  address1_lte?: Maybe<String>;
  address1_gt?: Maybe<String>;
  address1_gte?: Maybe<String>;
  address1_contains?: Maybe<String>;
  address1_not_contains?: Maybe<String>;
  address1_starts_with?: Maybe<String>;
  address1_not_starts_with?: Maybe<String>;
  address1_ends_with?: Maybe<String>;
  address1_not_ends_with?: Maybe<String>;
  address2?: Maybe<String>;
  address2_not?: Maybe<String>;
  address2_in?: Maybe<String[] | String>;
  address2_not_in?: Maybe<String[] | String>;
  address2_lt?: Maybe<String>;
  address2_lte?: Maybe<String>;
  address2_gt?: Maybe<String>;
  address2_gte?: Maybe<String>;
  address2_contains?: Maybe<String>;
  address2_not_contains?: Maybe<String>;
  address2_starts_with?: Maybe<String>;
  address2_not_starts_with?: Maybe<String>;
  address2_ends_with?: Maybe<String>;
  address2_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  region?: Maybe<String>;
  region_not?: Maybe<String>;
  region_in?: Maybe<String[] | String>;
  region_not_in?: Maybe<String[] | String>;
  region_lt?: Maybe<String>;
  region_lte?: Maybe<String>;
  region_gt?: Maybe<String>;
  region_gte?: Maybe<String>;
  region_contains?: Maybe<String>;
  region_not_contains?: Maybe<String>;
  region_starts_with?: Maybe<String>;
  region_not_starts_with?: Maybe<String>;
  region_ends_with?: Maybe<String>;
  region_not_ends_with?: Maybe<String>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  primary?: Maybe<Boolean>;
  primary_not?: Maybe<Boolean>;
  AND?: Maybe<AddressScalarWhereInput[] | AddressScalarWhereInput>;
  OR?: Maybe<AddressScalarWhereInput[] | AddressScalarWhereInput>;
  NOT?: Maybe<AddressScalarWhereInput[] | AddressScalarWhereInput>;
}

export interface RoleUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface AddressUpdateManyWithWhereNestedInput {
  where: AddressScalarWhereInput;
  data: AddressUpdateManyDataInput;
}

export type RoleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AddressUpdateManyDataInput {
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  region?: Maybe<String>;
  country?: Maybe<String>;
  code?: Maybe<String>;
  primary?: Maybe<Boolean>;
}

export interface UserUpdateWithWhereUniqueWithoutRolesInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutRolesDataInput;
}

export interface LessonUpdateManyWithoutAvailableTeachersInput {
  create?: Maybe<
    | LessonCreateWithoutAvailableTeachersInput[]
    | LessonCreateWithoutAvailableTeachersInput
  >;
  delete?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  connect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  set?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  disconnect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  update?: Maybe<
    | LessonUpdateWithWhereUniqueWithoutAvailableTeachersInput[]
    | LessonUpdateWithWhereUniqueWithoutAvailableTeachersInput
  >;
  upsert?: Maybe<
    | LessonUpsertWithWhereUniqueWithoutAvailableTeachersInput[]
    | LessonUpsertWithWhereUniqueWithoutAvailableTeachersInput
  >;
  deleteMany?: Maybe<LessonScalarWhereInput[] | LessonScalarWhereInput>;
  updateMany?: Maybe<
    | LessonUpdateManyWithWhereNestedInput[]
    | LessonUpdateManyWithWhereNestedInput
  >;
}

export type SessionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProductCreateManyWithoutCategoryInput {
  create?: Maybe<
    ProductCreateWithoutCategoryInput[] | ProductCreateWithoutCategoryInput
  >;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
}

export interface UserCreateWithoutRolesInput {
  id?: Maybe<ID_Input>;
  firstname: String;
  lastname: String;
  email: String;
  emailVerified?: Maybe<Boolean>;
  password: String;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressCreateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceCreateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentCreateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkCreateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  newses?: Maybe<NewsCreateManyWithoutAuthorInput>;
  events?: Maybe<EventCreateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonCreateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonCreateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionCreateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestCreateManyWithoutUserInput>;
}

export interface LessonUpdateWithoutAvailableTeachersDataInput {
  name?: Maybe<String>;
  subjects?: Maybe<SubjectUpdateManyWithoutLessonInput>;
  period?: Maybe<OperatingPeriodUpdateOneRequiredWithoutLessonsInput>;
  sessions?: Maybe<SessionUpdateManyWithoutLessonInput>;
  manager?: Maybe<UserUpdateOneRequiredWithoutLessonsManagedInput>;
}

export type SocialLinkWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  link?: Maybe<String>;
}>;

export interface SessionUpdateManyWithoutLessonInput {
  create?: Maybe<
    SessionCreateWithoutLessonInput[] | SessionCreateWithoutLessonInput
  >;
  delete?: Maybe<SessionWhereUniqueInput[] | SessionWhereUniqueInput>;
  connect?: Maybe<SessionWhereUniqueInput[] | SessionWhereUniqueInput>;
  set?: Maybe<SessionWhereUniqueInput[] | SessionWhereUniqueInput>;
  disconnect?: Maybe<SessionWhereUniqueInput[] | SessionWhereUniqueInput>;
  update?: Maybe<
    | SessionUpdateWithWhereUniqueWithoutLessonInput[]
    | SessionUpdateWithWhereUniqueWithoutLessonInput
  >;
  upsert?: Maybe<
    | SessionUpsertWithWhereUniqueWithoutLessonInput[]
    | SessionUpsertWithWhereUniqueWithoutLessonInput
  >;
  deleteMany?: Maybe<SessionScalarWhereInput[] | SessionScalarWhereInput>;
  updateMany?: Maybe<
    | SessionUpdateManyWithWhereNestedInput[]
    | SessionUpdateManyWithWhereNestedInput
  >;
}

export interface ProgramUpdateManyMutationInput {
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  description?: Maybe<String>;
}

export interface SessionUpdateWithWhereUniqueWithoutLessonInput {
  where: SessionWhereUniqueInput;
  data: SessionUpdateWithoutLessonDataInput;
}

export type SocialNetworkWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SessionUpdateWithoutLessonDataInput {
  closedAt?: Maybe<DateTimeInput>;
  by?: Maybe<UserUpdateOneRequiredWithoutTeachedSessionsInput>;
  at?: Maybe<SpaceUpdateOneRequiredWithoutSessionsInput>;
}

export interface BranchScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  shortName?: Maybe<String>;
  shortName_not?: Maybe<String>;
  shortName_in?: Maybe<String[] | String>;
  shortName_not_in?: Maybe<String[] | String>;
  shortName_lt?: Maybe<String>;
  shortName_lte?: Maybe<String>;
  shortName_gt?: Maybe<String>;
  shortName_gte?: Maybe<String>;
  shortName_contains?: Maybe<String>;
  shortName_not_contains?: Maybe<String>;
  shortName_starts_with?: Maybe<String>;
  shortName_not_starts_with?: Maybe<String>;
  shortName_ends_with?: Maybe<String>;
  shortName_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<BranchScalarWhereInput[] | BranchScalarWhereInput>;
  OR?: Maybe<BranchScalarWhereInput[] | BranchScalarWhereInput>;
  NOT?: Maybe<BranchScalarWhereInput[] | BranchScalarWhereInput>;
}

export interface UserUpdateOneRequiredWithoutTeachedSessionsInput {
  create?: Maybe<UserCreateWithoutTeachedSessionsInput>;
  update?: Maybe<UserUpdateWithoutTeachedSessionsDataInput>;
  upsert?: Maybe<UserUpsertWithoutTeachedSessionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface BranchUpdateWithoutProgramDataInput {
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  description?: Maybe<String>;
  subjects?: Maybe<SubjectUpdateManyWithoutBranchInput>;
}

export interface UserUpdateWithoutTeachedSessionsDataInput {
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  email?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  password?: Maybe<String>;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleUpdateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressUpdateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceUpdateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentUpdateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkUpdateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  newses?: Maybe<NewsUpdateManyWithoutAuthorInput>;
  events?: Maybe<EventUpdateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonUpdateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonUpdateManyWithoutAvailableTeachersInput>;
  discountRequests?: Maybe<DiscountRequestUpdateManyWithoutUserInput>;
}

export interface BranchUpdateWithWhereUniqueWithoutProgramInput {
  where: BranchWhereUniqueInput;
  data: BranchUpdateWithoutProgramDataInput;
}

export interface LessonUpdateManyWithoutManagerInput {
  create?: Maybe<
    LessonCreateWithoutManagerInput[] | LessonCreateWithoutManagerInput
  >;
  delete?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  connect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  set?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  disconnect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  update?: Maybe<
    | LessonUpdateWithWhereUniqueWithoutManagerInput[]
    | LessonUpdateWithWhereUniqueWithoutManagerInput
  >;
  upsert?: Maybe<
    | LessonUpsertWithWhereUniqueWithoutManagerInput[]
    | LessonUpsertWithWhereUniqueWithoutManagerInput
  >;
  deleteMany?: Maybe<LessonScalarWhereInput[] | LessonScalarWhereInput>;
  updateMany?: Maybe<
    | LessonUpdateManyWithWhereNestedInput[]
    | LessonUpdateManyWithWhereNestedInput
  >;
}

export interface ProgramUpdateInput {
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  description?: Maybe<String>;
  branches?: Maybe<BranchUpdateManyWithoutProgramInput>;
}

export interface LessonUpdateWithWhereUniqueWithoutManagerInput {
  where: LessonWhereUniqueInput;
  data: LessonUpdateWithoutManagerDataInput;
}

export interface BranchCreateWithoutProgramInput {
  id?: Maybe<ID_Input>;
  name: String;
  shortName: String;
  description?: Maybe<String>;
  subjects?: Maybe<SubjectCreateManyWithoutBranchInput>;
}

export interface LessonUpdateWithoutManagerDataInput {
  name?: Maybe<String>;
  subjects?: Maybe<SubjectUpdateManyWithoutLessonInput>;
  period?: Maybe<OperatingPeriodUpdateOneRequiredWithoutLessonsInput>;
  sessions?: Maybe<SessionUpdateManyWithoutLessonInput>;
  availableTeachers?: Maybe<UserUpdateManyWithoutAvailableLessonsInput>;
}

export interface ProgramCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  shortName: String;
  description?: Maybe<String>;
  branches?: Maybe<BranchCreateManyWithoutProgramInput>;
}

export interface UserUpdateManyWithoutAvailableLessonsInput {
  create?: Maybe<
    | UserCreateWithoutAvailableLessonsInput[]
    | UserCreateWithoutAvailableLessonsInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutAvailableLessonsInput[]
    | UserUpdateWithWhereUniqueWithoutAvailableLessonsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutAvailableLessonsInput[]
    | UserUpsertWithWhereUniqueWithoutAvailableLessonsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface ProductCategoryUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface UserUpdateWithWhereUniqueWithoutAvailableLessonsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutAvailableLessonsDataInput;
}

export interface ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput;
  data: ProductUpdateManyDataInput;
}

export interface UserUpdateWithoutAvailableLessonsDataInput {
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  email?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  password?: Maybe<String>;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleUpdateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressUpdateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceUpdateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentUpdateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkUpdateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  newses?: Maybe<NewsUpdateManyWithoutAuthorInput>;
  events?: Maybe<EventUpdateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonUpdateManyWithoutManagerInput>;
  teachedSessions?: Maybe<SessionUpdateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestUpdateManyWithoutUserInput>;
}

export interface ProductScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  unitPrice?: Maybe<Float>;
  unitPrice_not?: Maybe<Float>;
  unitPrice_in?: Maybe<Float[] | Float>;
  unitPrice_not_in?: Maybe<Float[] | Float>;
  unitPrice_lt?: Maybe<Float>;
  unitPrice_lte?: Maybe<Float>;
  unitPrice_gt?: Maybe<Float>;
  unitPrice_gte?: Maybe<Float>;
  AND?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  OR?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  NOT?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
}

export interface SessionUpdateManyWithoutByInput {
  create?: Maybe<SessionCreateWithoutByInput[] | SessionCreateWithoutByInput>;
  delete?: Maybe<SessionWhereUniqueInput[] | SessionWhereUniqueInput>;
  connect?: Maybe<SessionWhereUniqueInput[] | SessionWhereUniqueInput>;
  set?: Maybe<SessionWhereUniqueInput[] | SessionWhereUniqueInput>;
  disconnect?: Maybe<SessionWhereUniqueInput[] | SessionWhereUniqueInput>;
  update?: Maybe<
    | SessionUpdateWithWhereUniqueWithoutByInput[]
    | SessionUpdateWithWhereUniqueWithoutByInput
  >;
  upsert?: Maybe<
    | SessionUpsertWithWhereUniqueWithoutByInput[]
    | SessionUpsertWithWhereUniqueWithoutByInput
  >;
  deleteMany?: Maybe<SessionScalarWhereInput[] | SessionScalarWhereInput>;
  updateMany?: Maybe<
    | SessionUpdateManyWithWhereNestedInput[]
    | SessionUpdateManyWithWhereNestedInput
  >;
}

export interface ProductUpdateWithoutCategoryDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  content?: Maybe<String>;
  unitPrice?: Maybe<Float>;
  imageURLs?: Maybe<ProductUpdateimageURLsInput>;
  discounts?: Maybe<DiscountUpdateManyWithoutProductInput>;
  orders?: Maybe<ItemUpdateManyWithoutProductInput>;
}

export interface SessionUpdateWithWhereUniqueWithoutByInput {
  where: SessionWhereUniqueInput;
  data: SessionUpdateWithoutByDataInput;
}

export interface ProductUpdateWithWhereUniqueWithoutCategoryInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutCategoryDataInput;
}

export interface SessionUpdateWithoutByDataInput {
  lesson?: Maybe<LessonUpdateOneRequiredWithoutSessionsInput>;
  closedAt?: Maybe<DateTimeInput>;
  at?: Maybe<SpaceUpdateOneRequiredWithoutSessionsInput>;
}

export interface ProductCategoryUpdateInput {
  name?: Maybe<String>;
  products?: Maybe<ProductUpdateManyWithoutCategoryInput>;
}

export interface SpaceUpdateOneRequiredWithoutSessionsInput {
  create?: Maybe<SpaceCreateWithoutSessionsInput>;
  update?: Maybe<SpaceUpdateWithoutSessionsDataInput>;
  upsert?: Maybe<SpaceUpsertWithoutSessionsInput>;
  connect?: Maybe<SpaceWhereUniqueInput>;
}

export interface UserCreateOneWithoutAddressesInput {
  create?: Maybe<UserCreateWithoutAddressesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ProductCategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  products_every?: Maybe<ProductWhereInput>;
  products_some?: Maybe<ProductWhereInput>;
  products_none?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductCategoryWhereInput[] | ProductCategoryWhereInput>;
  OR?: Maybe<ProductCategoryWhereInput[] | ProductCategoryWhereInput>;
  NOT?: Maybe<ProductCategoryWhereInput[] | ProductCategoryWhereInput>;
}

export interface RoleCreateManyWithoutUsersInput {
  create?: Maybe<RoleCreateWithoutUsersInput[] | RoleCreateWithoutUsersInput>;
  connect?: Maybe<RoleWhereUniqueInput[] | RoleWhereUniqueInput>;
}

export interface OrderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  customer?: Maybe<UserWhereInput>;
  items_every?: Maybe<ItemWhereInput>;
  items_some?: Maybe<ItemWhereInput>;
  items_none?: Maybe<ItemWhereInput>;
  reference?: Maybe<String>;
  reference_not?: Maybe<String>;
  reference_in?: Maybe<String[] | String>;
  reference_not_in?: Maybe<String[] | String>;
  reference_lt?: Maybe<String>;
  reference_lte?: Maybe<String>;
  reference_gt?: Maybe<String>;
  reference_gte?: Maybe<String>;
  reference_contains?: Maybe<String>;
  reference_not_contains?: Maybe<String>;
  reference_starts_with?: Maybe<String>;
  reference_not_starts_with?: Maybe<String>;
  reference_ends_with?: Maybe<String>;
  reference_not_ends_with?: Maybe<String>;
  paymentSettled?: Maybe<Boolean>;
  paymentSettled_not?: Maybe<Boolean>;
  paymentDue?: Maybe<DateTimeInput>;
  paymentDue_not?: Maybe<DateTimeInput>;
  paymentDue_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  paymentDue_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  paymentDue_lt?: Maybe<DateTimeInput>;
  paymentDue_lte?: Maybe<DateTimeInput>;
  paymentDue_gt?: Maybe<DateTimeInput>;
  paymentDue_gte?: Maybe<DateTimeInput>;
  transactions_every?: Maybe<TransactionWhereInput>;
  transactions_some?: Maybe<TransactionWhereInput>;
  transactions_none?: Maybe<TransactionWhereInput>;
  vatRate?: Maybe<Int>;
  vatRate_not?: Maybe<Int>;
  vatRate_in?: Maybe<Int[] | Int>;
  vatRate_not_in?: Maybe<Int[] | Int>;
  vatRate_lt?: Maybe<Int>;
  vatRate_lte?: Maybe<Int>;
  vatRate_gt?: Maybe<Int>;
  vatRate_gte?: Maybe<Int>;
  total?: Maybe<Float>;
  total_not?: Maybe<Float>;
  total_in?: Maybe<Float[] | Float>;
  total_not_in?: Maybe<Float[] | Float>;
  total_lt?: Maybe<Float>;
  total_lte?: Maybe<Float>;
  total_gt?: Maybe<Float>;
  total_gte?: Maybe<Float>;
  AND?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  OR?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  NOT?: Maybe<OrderWhereInput[] | OrderWhereInput>;
}

export interface DeviceCreateManyWithoutOwnerInput {
  create?: Maybe<
    DeviceCreateWithoutOwnerInput[] | DeviceCreateWithoutOwnerInput
  >;
  connect?: Maybe<DeviceWhereUniqueInput[] | DeviceWhereUniqueInput>;
}

export interface DiscountWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  product?: Maybe<ProductWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  unitPrice?: Maybe<Float>;
  unitPrice_not?: Maybe<Float>;
  unitPrice_in?: Maybe<Float[] | Float>;
  unitPrice_not_in?: Maybe<Float[] | Float>;
  unitPrice_lt?: Maybe<Float>;
  unitPrice_lte?: Maybe<Float>;
  unitPrice_gt?: Maybe<Float>;
  unitPrice_gte?: Maybe<Float>;
  discountRequests_every?: Maybe<DiscountRequestWhereInput>;
  discountRequests_some?: Maybe<DiscountRequestWhereInput>;
  discountRequests_none?: Maybe<DiscountRequestWhereInput>;
  requirements?: Maybe<String>;
  requirements_not?: Maybe<String>;
  requirements_in?: Maybe<String[] | String>;
  requirements_not_in?: Maybe<String[] | String>;
  requirements_lt?: Maybe<String>;
  requirements_lte?: Maybe<String>;
  requirements_gt?: Maybe<String>;
  requirements_gte?: Maybe<String>;
  requirements_contains?: Maybe<String>;
  requirements_not_contains?: Maybe<String>;
  requirements_starts_with?: Maybe<String>;
  requirements_not_starts_with?: Maybe<String>;
  requirements_ends_with?: Maybe<String>;
  requirements_not_ends_with?: Maybe<String>;
  AND?: Maybe<DiscountWhereInput[] | DiscountWhereInput>;
  OR?: Maybe<DiscountWhereInput[] | DiscountWhereInput>;
  NOT?: Maybe<DiscountWhereInput[] | DiscountWhereInput>;
}

export interface OfficialDocumentCreateManyWithoutOwnerInput {
  create?: Maybe<
    | OfficialDocumentCreateWithoutOwnerInput[]
    | OfficialDocumentCreateWithoutOwnerInput
  >;
  connect?: Maybe<
    OfficialDocumentWhereUniqueInput[] | OfficialDocumentWhereUniqueInput
  >;
}

export interface ProductCategoryCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  products?: Maybe<ProductCreateManyWithoutCategoryInput>;
}

export interface SocialLinkCreateManyWithoutOwnerInput {
  create?: Maybe<
    SocialLinkCreateWithoutOwnerInput[] | SocialLinkCreateWithoutOwnerInput
  >;
  connect?: Maybe<SocialLinkWhereUniqueInput[] | SocialLinkWhereUniqueInput>;
}

export interface OperatingPeriodWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  yearStart?: Maybe<Int>;
  yearStart_not?: Maybe<Int>;
  yearStart_in?: Maybe<Int[] | Int>;
  yearStart_not_in?: Maybe<Int[] | Int>;
  yearStart_lt?: Maybe<Int>;
  yearStart_lte?: Maybe<Int>;
  yearStart_gt?: Maybe<Int>;
  yearStart_gte?: Maybe<Int>;
  yearEnd?: Maybe<Int>;
  yearEnd_not?: Maybe<Int>;
  yearEnd_in?: Maybe<Int[] | Int>;
  yearEnd_not_in?: Maybe<Int[] | Int>;
  yearEnd_lt?: Maybe<Int>;
  yearEnd_lte?: Maybe<Int>;
  yearEnd_gt?: Maybe<Int>;
  yearEnd_gte?: Maybe<Int>;
  lessons_every?: Maybe<LessonWhereInput>;
  lessons_some?: Maybe<LessonWhereInput>;
  lessons_none?: Maybe<LessonWhereInput>;
  AND?: Maybe<OperatingPeriodWhereInput[] | OperatingPeriodWhereInput>;
  OR?: Maybe<OperatingPeriodWhereInput[] | OperatingPeriodWhereInput>;
  NOT?: Maybe<OperatingPeriodWhereInput[] | OperatingPeriodWhereInput>;
}

export interface SocialNetworkCreateOneWithoutUserLinksInput {
  create?: Maybe<SocialNetworkCreateWithoutUserLinksInput>;
  connect?: Maybe<SocialNetworkWhereUniqueInput>;
}

export interface UserUpdateWithoutEventsDataInput {
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  email?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  password?: Maybe<String>;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleUpdateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressUpdateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceUpdateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentUpdateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkUpdateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  newses?: Maybe<NewsUpdateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonUpdateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonUpdateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionUpdateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestUpdateManyWithoutUserInput>;
}

export interface DepartmentCreateOneWithoutMembersInput {
  create?: Maybe<DepartmentCreateWithoutMembersInput>;
  connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface DiscountRequestUpdateManyWithoutUserInput {
  create?: Maybe<
    | DiscountRequestCreateWithoutUserInput[]
    | DiscountRequestCreateWithoutUserInput
  >;
  delete?: Maybe<
    DiscountRequestWhereUniqueInput[] | DiscountRequestWhereUniqueInput
  >;
  connect?: Maybe<
    DiscountRequestWhereUniqueInput[] | DiscountRequestWhereUniqueInput
  >;
  set?: Maybe<
    DiscountRequestWhereUniqueInput[] | DiscountRequestWhereUniqueInput
  >;
  disconnect?: Maybe<
    DiscountRequestWhereUniqueInput[] | DiscountRequestWhereUniqueInput
  >;
  update?: Maybe<
    | DiscountRequestUpdateWithWhereUniqueWithoutUserInput[]
    | DiscountRequestUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | DiscountRequestUpsertWithWhereUniqueWithoutUserInput[]
    | DiscountRequestUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    DiscountRequestScalarWhereInput[] | DiscountRequestScalarWhereInput
  >;
  updateMany?: Maybe<
    | DiscountRequestUpdateManyWithWhereNestedInput[]
    | DiscountRequestUpdateManyWithWhereNestedInput
  >;
}

export interface NewsCreateManyWithoutAuthorInput {
  create?: Maybe<NewsCreateWithoutAuthorInput[] | NewsCreateWithoutAuthorInput>;
  connect?: Maybe<NewsWhereUniqueInput[] | NewsWhereUniqueInput>;
}

export interface DiscountRequestUpdateWithWhereUniqueWithoutUserInput {
  where: DiscountRequestWhereUniqueInput;
  data: DiscountRequestUpdateWithoutUserDataInput;
}

export interface EventCreateManyWithoutAuthorInput {
  create?: Maybe<
    EventCreateWithoutAuthorInput[] | EventCreateWithoutAuthorInput
  >;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
}

export interface DiscountRequestUpdateWithoutUserDataInput {
  discount?: Maybe<DiscountUpdateOneRequiredWithoutDiscountRequestsInput>;
  applied?: Maybe<Boolean>;
  approved?: Maybe<Boolean>;
  documentation?: Maybe<DiscountRequestUpdatedocumentationInput>;
}

export interface SpaceCreateOneWithoutEventsInput {
  create?: Maybe<SpaceCreateWithoutEventsInput>;
  connect?: Maybe<SpaceWhereUniqueInput>;
}

export interface DiscountUpdateOneRequiredWithoutDiscountRequestsInput {
  create?: Maybe<DiscountCreateWithoutDiscountRequestsInput>;
  update?: Maybe<DiscountUpdateWithoutDiscountRequestsDataInput>;
  upsert?: Maybe<DiscountUpsertWithoutDiscountRequestsInput>;
  connect?: Maybe<DiscountWhereUniqueInput>;
}

export interface VenueCreateOneWithoutSpacesInput {
  create?: Maybe<VenueCreateWithoutSpacesInput>;
  connect?: Maybe<VenueWhereUniqueInput>;
}

export interface DiscountUpdateWithoutDiscountRequestsDataInput {
  product?: Maybe<ProductUpdateOneRequiredWithoutDiscountsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  code?: Maybe<String>;
  unitPrice?: Maybe<Float>;
  requirements?: Maybe<String>;
}

export interface SessionCreateManyWithoutAtInput {
  create?: Maybe<SessionCreateWithoutAtInput[] | SessionCreateWithoutAtInput>;
  connect?: Maybe<SessionWhereUniqueInput[] | SessionWhereUniqueInput>;
}

export interface ProductUpdateOneRequiredWithoutDiscountsInput {
  create?: Maybe<ProductCreateWithoutDiscountsInput>;
  update?: Maybe<ProductUpdateWithoutDiscountsDataInput>;
  upsert?: Maybe<ProductUpsertWithoutDiscountsInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface LessonCreateOneWithoutSessionsInput {
  create?: Maybe<LessonCreateWithoutSessionsInput>;
  connect?: Maybe<LessonWhereUniqueInput>;
}

export interface ProductUpdateWithoutDiscountsDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  content?: Maybe<String>;
  unitPrice?: Maybe<Float>;
  category?: Maybe<ProductCategoryUpdateOneRequiredWithoutProductsInput>;
  imageURLs?: Maybe<ProductUpdateimageURLsInput>;
  orders?: Maybe<ItemUpdateManyWithoutProductInput>;
}

export interface SubjectCreateManyWithoutLessonInput {
  create?: Maybe<
    SubjectCreateWithoutLessonInput[] | SubjectCreateWithoutLessonInput
  >;
  connect?: Maybe<SubjectWhereUniqueInput[] | SubjectWhereUniqueInput>;
}

export interface ProductCategoryUpdateOneRequiredWithoutProductsInput {
  create?: Maybe<ProductCategoryCreateWithoutProductsInput>;
  update?: Maybe<ProductCategoryUpdateWithoutProductsDataInput>;
  upsert?: Maybe<ProductCategoryUpsertWithoutProductsInput>;
  connect?: Maybe<ProductCategoryWhereUniqueInput>;
}

export interface BranchCreateOneWithoutSubjectsInput {
  create?: Maybe<BranchCreateWithoutSubjectsInput>;
  connect?: Maybe<BranchWhereUniqueInput>;
}

export interface ProductCategoryUpdateWithoutProductsDataInput {
  name?: Maybe<String>;
}

export interface ProgramCreateOneWithoutBranchesInput {
  create?: Maybe<ProgramCreateWithoutBranchesInput>;
  connect?: Maybe<ProgramWhereUniqueInput>;
}

export interface ProductCategoryUpsertWithoutProductsInput {
  update: ProductCategoryUpdateWithoutProductsDataInput;
  create: ProductCategoryCreateWithoutProductsInput;
}

export interface OperatingPeriodCreateOneWithoutLessonsInput {
  create?: Maybe<OperatingPeriodCreateWithoutLessonsInput>;
  connect?: Maybe<OperatingPeriodWhereUniqueInput>;
}

export interface ProductUpdateimageURLsInput {
  set?: Maybe<String[] | String>;
}

export interface UserCreateOneWithoutLessonsManagedInput {
  create?: Maybe<UserCreateWithoutLessonsManagedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ItemUpdateManyWithoutProductInput {
  create?: Maybe<
    ItemCreateWithoutProductInput[] | ItemCreateWithoutProductInput
  >;
  delete?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  set?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  disconnect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  update?: Maybe<
    | ItemUpdateWithWhereUniqueWithoutProductInput[]
    | ItemUpdateWithWhereUniqueWithoutProductInput
  >;
  upsert?: Maybe<
    | ItemUpsertWithWhereUniqueWithoutProductInput[]
    | ItemUpsertWithWhereUniqueWithoutProductInput
  >;
  deleteMany?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  updateMany?: Maybe<
    ItemUpdateManyWithWhereNestedInput[] | ItemUpdateManyWithWhereNestedInput
  >;
}

export interface AddressCreateManyWithoutOwnerInput {
  create?: Maybe<
    AddressCreateWithoutOwnerInput[] | AddressCreateWithoutOwnerInput
  >;
  connect?: Maybe<AddressWhereUniqueInput[] | AddressWhereUniqueInput>;
}

export interface ItemUpdateWithWhereUniqueWithoutProductInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateWithoutProductDataInput;
}

export interface LessonCreateManyWithoutAvailableTeachersInput {
  create?: Maybe<
    | LessonCreateWithoutAvailableTeachersInput[]
    | LessonCreateWithoutAvailableTeachersInput
  >;
  connect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
}

export interface ItemUpdateWithoutProductDataInput {
  order?: Maybe<OrderUpdateOneRequiredWithoutItemsInput>;
  discount?: Maybe<DiscountUpdateOneInput>;
  quantity?: Maybe<Int>;
  orderPrice?: Maybe<Float>;
}

export interface SessionCreateManyWithoutLessonInput {
  create?: Maybe<
    SessionCreateWithoutLessonInput[] | SessionCreateWithoutLessonInput
  >;
  connect?: Maybe<SessionWhereUniqueInput[] | SessionWhereUniqueInput>;
}

export interface OrderUpdateOneRequiredWithoutItemsInput {
  create?: Maybe<OrderCreateWithoutItemsInput>;
  update?: Maybe<OrderUpdateWithoutItemsDataInput>;
  upsert?: Maybe<OrderUpsertWithoutItemsInput>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface UserCreateOneWithoutTeachedSessionsInput {
  create?: Maybe<UserCreateWithoutTeachedSessionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface OrderUpdateWithoutItemsDataInput {
  customer?: Maybe<UserUpdateOneRequiredInput>;
  reference?: Maybe<String>;
  metadata?: Maybe<Json>;
  paymentSettled?: Maybe<Boolean>;
  paymentDue?: Maybe<DateTimeInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutOrderInput>;
  vatRate?: Maybe<Int>;
  total?: Maybe<Float>;
}

export interface LessonCreateManyWithoutManagerInput {
  create?: Maybe<
    LessonCreateWithoutManagerInput[] | LessonCreateWithoutManagerInput
  >;
  connect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateManyWithoutAvailableLessonsInput {
  create?: Maybe<
    | UserCreateWithoutAvailableLessonsInput[]
    | UserCreateWithoutAvailableLessonsInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  email?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  password?: Maybe<String>;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleUpdateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressUpdateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceUpdateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentUpdateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkUpdateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  newses?: Maybe<NewsUpdateManyWithoutAuthorInput>;
  events?: Maybe<EventUpdateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonUpdateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonUpdateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionUpdateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestUpdateManyWithoutUserInput>;
}

export interface SessionCreateManyWithoutByInput {
  create?: Maybe<SessionCreateWithoutByInput[] | SessionCreateWithoutByInput>;
  connect?: Maybe<SessionWhereUniqueInput[] | SessionWhereUniqueInput>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface SpaceCreateOneWithoutSessionsInput {
  create?: Maybe<SpaceCreateWithoutSessionsInput>;
  connect?: Maybe<SpaceWhereUniqueInput>;
}

export interface TransactionUpdateManyWithoutOrderInput {
  create?: Maybe<
    TransactionCreateWithoutOrderInput[] | TransactionCreateWithoutOrderInput
  >;
  delete?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
  connect?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
  set?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
  disconnect?: Maybe<
    TransactionWhereUniqueInput[] | TransactionWhereUniqueInput
  >;
  update?: Maybe<
    | TransactionUpdateWithWhereUniqueWithoutOrderInput[]
    | TransactionUpdateWithWhereUniqueWithoutOrderInput
  >;
  upsert?: Maybe<
    | TransactionUpsertWithWhereUniqueWithoutOrderInput[]
    | TransactionUpsertWithWhereUniqueWithoutOrderInput
  >;
  deleteMany?: Maybe<
    TransactionScalarWhereInput[] | TransactionScalarWhereInput
  >;
  updateMany?: Maybe<
    | TransactionUpdateManyWithWhereNestedInput[]
    | TransactionUpdateManyWithWhereNestedInput
  >;
}

export interface EventCreateManyWithoutPlaceInput {
  create?: Maybe<EventCreateWithoutPlaceInput[] | EventCreateWithoutPlaceInput>;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
}

export interface TransactionUpdateWithWhereUniqueWithoutOrderInput {
  where: TransactionWhereUniqueInput;
  data: TransactionUpdateWithoutOrderDataInput;
}

export interface UserCreateOneWithoutEventsInput {
  create?: Maybe<UserCreateWithoutEventsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface TransactionUpdateWithoutOrderDataInput {
  type?: Maybe<TxType>;
  reference?: Maybe<String>;
  amount?: Maybe<Int>;
}

export interface DiscountRequestCreateManyWithoutUserInput {
  create?: Maybe<
    | DiscountRequestCreateWithoutUserInput[]
    | DiscountRequestCreateWithoutUserInput
  >;
  connect?: Maybe<
    DiscountRequestWhereUniqueInput[] | DiscountRequestWhereUniqueInput
  >;
}

export interface TransactionUpsertWithWhereUniqueWithoutOrderInput {
  where: TransactionWhereUniqueInput;
  update: TransactionUpdateWithoutOrderDataInput;
  create: TransactionCreateWithoutOrderInput;
}

export interface DiscountCreateOneWithoutDiscountRequestsInput {
  create?: Maybe<DiscountCreateWithoutDiscountRequestsInput>;
  connect?: Maybe<DiscountWhereUniqueInput>;
}

export interface TransactionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  type?: Maybe<TxType>;
  type_not?: Maybe<TxType>;
  type_in?: Maybe<TxType[] | TxType>;
  type_not_in?: Maybe<TxType[] | TxType>;
  reference?: Maybe<String>;
  reference_not?: Maybe<String>;
  reference_in?: Maybe<String[] | String>;
  reference_not_in?: Maybe<String[] | String>;
  reference_lt?: Maybe<String>;
  reference_lte?: Maybe<String>;
  reference_gt?: Maybe<String>;
  reference_gte?: Maybe<String>;
  reference_contains?: Maybe<String>;
  reference_not_contains?: Maybe<String>;
  reference_starts_with?: Maybe<String>;
  reference_not_starts_with?: Maybe<String>;
  reference_ends_with?: Maybe<String>;
  reference_not_ends_with?: Maybe<String>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  AND?: Maybe<TransactionScalarWhereInput[] | TransactionScalarWhereInput>;
  OR?: Maybe<TransactionScalarWhereInput[] | TransactionScalarWhereInput>;
  NOT?: Maybe<TransactionScalarWhereInput[] | TransactionScalarWhereInput>;
}

export interface ProductCreateOneWithoutDiscountsInput {
  create?: Maybe<ProductCreateWithoutDiscountsInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface TransactionUpdateManyWithWhereNestedInput {
  where: TransactionScalarWhereInput;
  data: TransactionUpdateManyDataInput;
}

export interface ProductCategoryCreateOneWithoutProductsInput {
  create?: Maybe<ProductCategoryCreateWithoutProductsInput>;
  connect?: Maybe<ProductCategoryWhereUniqueInput>;
}

export interface TransactionUpdateManyDataInput {
  type?: Maybe<TxType>;
  reference?: Maybe<String>;
  amount?: Maybe<Int>;
}

export interface ProductCreateimageURLsInput {
  set?: Maybe<String[] | String>;
}

export interface OrderUpsertWithoutItemsInput {
  update: OrderUpdateWithoutItemsDataInput;
  create: OrderCreateWithoutItemsInput;
}

export interface ItemCreateWithoutProductInput {
  id?: Maybe<ID_Input>;
  order: OrderCreateOneWithoutItemsInput;
  discount?: Maybe<DiscountCreateOneInput>;
  quantity: Int;
  orderPrice: Float;
}

export interface DiscountUpdateOneInput {
  create?: Maybe<DiscountCreateInput>;
  update?: Maybe<DiscountUpdateDataInput>;
  upsert?: Maybe<DiscountUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<DiscountWhereUniqueInput>;
}

export interface OrderCreateWithoutItemsInput {
  id?: Maybe<ID_Input>;
  customer: UserCreateOneInput;
  reference: String;
  metadata?: Maybe<Json>;
  paymentSettled?: Maybe<Boolean>;
  paymentDue?: Maybe<DateTimeInput>;
  transactions?: Maybe<TransactionCreateManyWithoutOrderInput>;
  vatRate?: Maybe<Int>;
  total: Float;
}

export interface DiscountUpdateDataInput {
  product?: Maybe<ProductUpdateOneRequiredWithoutDiscountsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  code?: Maybe<String>;
  unitPrice?: Maybe<Float>;
  discountRequests?: Maybe<DiscountRequestUpdateManyWithoutDiscountInput>;
  requirements?: Maybe<String>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  firstname: String;
  lastname: String;
  email: String;
  emailVerified?: Maybe<Boolean>;
  password: String;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleCreateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressCreateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceCreateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentCreateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkCreateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  newses?: Maybe<NewsCreateManyWithoutAuthorInput>;
  events?: Maybe<EventCreateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonCreateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonCreateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionCreateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestCreateManyWithoutUserInput>;
}

export interface DiscountRequestUpdateManyWithoutDiscountInput {
  create?: Maybe<
    | DiscountRequestCreateWithoutDiscountInput[]
    | DiscountRequestCreateWithoutDiscountInput
  >;
  delete?: Maybe<
    DiscountRequestWhereUniqueInput[] | DiscountRequestWhereUniqueInput
  >;
  connect?: Maybe<
    DiscountRequestWhereUniqueInput[] | DiscountRequestWhereUniqueInput
  >;
  set?: Maybe<
    DiscountRequestWhereUniqueInput[] | DiscountRequestWhereUniqueInput
  >;
  disconnect?: Maybe<
    DiscountRequestWhereUniqueInput[] | DiscountRequestWhereUniqueInput
  >;
  update?: Maybe<
    | DiscountRequestUpdateWithWhereUniqueWithoutDiscountInput[]
    | DiscountRequestUpdateWithWhereUniqueWithoutDiscountInput
  >;
  upsert?: Maybe<
    | DiscountRequestUpsertWithWhereUniqueWithoutDiscountInput[]
    | DiscountRequestUpsertWithWhereUniqueWithoutDiscountInput
  >;
  deleteMany?: Maybe<
    DiscountRequestScalarWhereInput[] | DiscountRequestScalarWhereInput
  >;
  updateMany?: Maybe<
    | DiscountRequestUpdateManyWithWhereNestedInput[]
    | DiscountRequestUpdateManyWithWhereNestedInput
  >;
}

export interface TransactionCreateWithoutOrderInput {
  id?: Maybe<ID_Input>;
  type?: Maybe<TxType>;
  reference?: Maybe<String>;
  amount: Int;
}

export interface DiscountRequestUpdateWithWhereUniqueWithoutDiscountInput {
  where: DiscountRequestWhereUniqueInput;
  data: DiscountRequestUpdateWithoutDiscountDataInput;
}

export interface DiscountCreateInput {
  id?: Maybe<ID_Input>;
  product: ProductCreateOneWithoutDiscountsInput;
  name: String;
  description: String;
  code?: Maybe<String>;
  unitPrice: Float;
  discountRequests?: Maybe<DiscountRequestCreateManyWithoutDiscountInput>;
  requirements: String;
}

export interface DiscountRequestUpdateWithoutDiscountDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutDiscountRequestsInput>;
  applied?: Maybe<Boolean>;
  approved?: Maybe<Boolean>;
  documentation?: Maybe<DiscountRequestUpdatedocumentationInput>;
}

export interface DiscountRequestCreateWithoutDiscountInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutDiscountRequestsInput;
  applied?: Maybe<Boolean>;
  approved?: Maybe<Boolean>;
  documentation?: Maybe<DiscountRequestCreatedocumentationInput>;
}

export interface UserUpdateOneRequiredWithoutDiscountRequestsInput {
  create?: Maybe<UserCreateWithoutDiscountRequestsInput>;
  update?: Maybe<UserUpdateWithoutDiscountRequestsDataInput>;
  upsert?: Maybe<UserUpsertWithoutDiscountRequestsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutDiscountRequestsInput {
  id?: Maybe<ID_Input>;
  firstname: String;
  lastname: String;
  email: String;
  emailVerified?: Maybe<Boolean>;
  password: String;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleCreateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressCreateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceCreateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentCreateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkCreateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  newses?: Maybe<NewsCreateManyWithoutAuthorInput>;
  events?: Maybe<EventCreateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonCreateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonCreateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionCreateManyWithoutByInput>;
}

export interface UserUpdateWithoutDiscountRequestsDataInput {
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  email?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  password?: Maybe<String>;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleUpdateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressUpdateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceUpdateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentUpdateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkUpdateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  newses?: Maybe<NewsUpdateManyWithoutAuthorInput>;
  events?: Maybe<EventUpdateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonUpdateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonUpdateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionUpdateManyWithoutByInput>;
}

export interface AddressUpdateInput {
  owner?: Maybe<UserUpdateOneWithoutAddressesInput>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  region?: Maybe<String>;
  country?: Maybe<String>;
  code?: Maybe<String>;
  primary?: Maybe<Boolean>;
}

export interface UserUpsertWithoutDiscountRequestsInput {
  update: UserUpdateWithoutDiscountRequestsDataInput;
  create: UserCreateWithoutDiscountRequestsInput;
}

export interface UserUpdateWithoutAddressesDataInput {
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  email?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  password?: Maybe<String>;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleUpdateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  devices?: Maybe<DeviceUpdateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentUpdateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkUpdateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  newses?: Maybe<NewsUpdateManyWithoutAuthorInput>;
  events?: Maybe<EventUpdateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonUpdateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonUpdateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionUpdateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestUpdateManyWithoutUserInput>;
}

export interface DiscountRequestUpdatedocumentationInput {
  set?: Maybe<String[] | String>;
}

export interface RoleUpdateWithWhereUniqueWithoutUsersInput {
  where: RoleWhereUniqueInput;
  data: RoleUpdateWithoutUsersDataInput;
}

export interface DiscountRequestUpsertWithWhereUniqueWithoutDiscountInput {
  where: DiscountRequestWhereUniqueInput;
  update: DiscountRequestUpdateWithoutDiscountDataInput;
  create: DiscountRequestCreateWithoutDiscountInput;
}

export interface RoleUpsertWithWhereUniqueWithoutUsersInput {
  where: RoleWhereUniqueInput;
  update: RoleUpdateWithoutUsersDataInput;
  create: RoleCreateWithoutUsersInput;
}

export interface DiscountRequestScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  applied?: Maybe<Boolean>;
  applied_not?: Maybe<Boolean>;
  approved?: Maybe<Boolean>;
  approved_not?: Maybe<Boolean>;
  AND?: Maybe<
    DiscountRequestScalarWhereInput[] | DiscountRequestScalarWhereInput
  >;
  OR?: Maybe<
    DiscountRequestScalarWhereInput[] | DiscountRequestScalarWhereInput
  >;
  NOT?: Maybe<
    DiscountRequestScalarWhereInput[] | DiscountRequestScalarWhereInput
  >;
}

export interface RoleUpdateManyWithWhereNestedInput {
  where: RoleScalarWhereInput;
  data: RoleUpdateManyDataInput;
}

export interface DiscountRequestUpdateManyWithWhereNestedInput {
  where: DiscountRequestScalarWhereInput;
  data: DiscountRequestUpdateManyDataInput;
}

export interface DeviceUpdateManyWithoutOwnerInput {
  create?: Maybe<
    DeviceCreateWithoutOwnerInput[] | DeviceCreateWithoutOwnerInput
  >;
  delete?: Maybe<DeviceWhereUniqueInput[] | DeviceWhereUniqueInput>;
  connect?: Maybe<DeviceWhereUniqueInput[] | DeviceWhereUniqueInput>;
  set?: Maybe<DeviceWhereUniqueInput[] | DeviceWhereUniqueInput>;
  disconnect?: Maybe<DeviceWhereUniqueInput[] | DeviceWhereUniqueInput>;
  update?: Maybe<
    | DeviceUpdateWithWhereUniqueWithoutOwnerInput[]
    | DeviceUpdateWithWhereUniqueWithoutOwnerInput
  >;
  upsert?: Maybe<
    | DeviceUpsertWithWhereUniqueWithoutOwnerInput[]
    | DeviceUpsertWithWhereUniqueWithoutOwnerInput
  >;
  deleteMany?: Maybe<DeviceScalarWhereInput[] | DeviceScalarWhereInput>;
  updateMany?: Maybe<
    | DeviceUpdateManyWithWhereNestedInput[]
    | DeviceUpdateManyWithWhereNestedInput
  >;
}

export interface DiscountRequestUpdateManyDataInput {
  applied?: Maybe<Boolean>;
  approved?: Maybe<Boolean>;
  documentation?: Maybe<DiscountRequestUpdatedocumentationInput>;
}

export interface DeviceUpdateWithoutOwnerDataInput {
  countryCode?: Maybe<String>;
  number?: Maybe<String>;
  type?: Maybe<DeviceType>;
  notificationsDevice?: Maybe<String>;
  notificationsPermission?: Maybe<Boolean>;
  verified?: Maybe<Boolean>;
}

export interface DiscountUpsertNestedInput {
  update: DiscountUpdateDataInput;
  create: DiscountCreateInput;
}

export interface DeviceScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  countryCode?: Maybe<String>;
  countryCode_not?: Maybe<String>;
  countryCode_in?: Maybe<String[] | String>;
  countryCode_not_in?: Maybe<String[] | String>;
  countryCode_lt?: Maybe<String>;
  countryCode_lte?: Maybe<String>;
  countryCode_gt?: Maybe<String>;
  countryCode_gte?: Maybe<String>;
  countryCode_contains?: Maybe<String>;
  countryCode_not_contains?: Maybe<String>;
  countryCode_starts_with?: Maybe<String>;
  countryCode_not_starts_with?: Maybe<String>;
  countryCode_ends_with?: Maybe<String>;
  countryCode_not_ends_with?: Maybe<String>;
  number?: Maybe<String>;
  number_not?: Maybe<String>;
  number_in?: Maybe<String[] | String>;
  number_not_in?: Maybe<String[] | String>;
  number_lt?: Maybe<String>;
  number_lte?: Maybe<String>;
  number_gt?: Maybe<String>;
  number_gte?: Maybe<String>;
  number_contains?: Maybe<String>;
  number_not_contains?: Maybe<String>;
  number_starts_with?: Maybe<String>;
  number_not_starts_with?: Maybe<String>;
  number_ends_with?: Maybe<String>;
  number_not_ends_with?: Maybe<String>;
  type?: Maybe<DeviceType>;
  type_not?: Maybe<DeviceType>;
  type_in?: Maybe<DeviceType[] | DeviceType>;
  type_not_in?: Maybe<DeviceType[] | DeviceType>;
  notificationsDevice?: Maybe<String>;
  notificationsDevice_not?: Maybe<String>;
  notificationsDevice_in?: Maybe<String[] | String>;
  notificationsDevice_not_in?: Maybe<String[] | String>;
  notificationsDevice_lt?: Maybe<String>;
  notificationsDevice_lte?: Maybe<String>;
  notificationsDevice_gt?: Maybe<String>;
  notificationsDevice_gte?: Maybe<String>;
  notificationsDevice_contains?: Maybe<String>;
  notificationsDevice_not_contains?: Maybe<String>;
  notificationsDevice_starts_with?: Maybe<String>;
  notificationsDevice_not_starts_with?: Maybe<String>;
  notificationsDevice_ends_with?: Maybe<String>;
  notificationsDevice_not_ends_with?: Maybe<String>;
  notificationsPermission?: Maybe<Boolean>;
  notificationsPermission_not?: Maybe<Boolean>;
  verified?: Maybe<Boolean>;
  verified_not?: Maybe<Boolean>;
  AND?: Maybe<DeviceScalarWhereInput[] | DeviceScalarWhereInput>;
  OR?: Maybe<DeviceScalarWhereInput[] | DeviceScalarWhereInput>;
  NOT?: Maybe<DeviceScalarWhereInput[] | DeviceScalarWhereInput>;
}

export interface ItemUpsertWithWhereUniqueWithoutProductInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateWithoutProductDataInput;
  create: ItemCreateWithoutProductInput;
}

export interface DeviceUpdateManyDataInput {
  countryCode?: Maybe<String>;
  number?: Maybe<String>;
  type?: Maybe<DeviceType>;
  notificationsDevice?: Maybe<String>;
  notificationsPermission?: Maybe<Boolean>;
  verified?: Maybe<Boolean>;
}

export interface ItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  orderPrice?: Maybe<Float>;
  orderPrice_not?: Maybe<Float>;
  orderPrice_in?: Maybe<Float[] | Float>;
  orderPrice_not_in?: Maybe<Float[] | Float>;
  orderPrice_lt?: Maybe<Float>;
  orderPrice_lte?: Maybe<Float>;
  orderPrice_gt?: Maybe<Float>;
  orderPrice_gte?: Maybe<Float>;
  AND?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  OR?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  NOT?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
}

export interface OfficialDocumentUpdateWithWhereUniqueWithoutOwnerInput {
  where: OfficialDocumentWhereUniqueInput;
  data: OfficialDocumentUpdateWithoutOwnerDataInput;
}

export interface ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput;
  data: ItemUpdateManyDataInput;
}

export interface OfficialDocumentUpsertWithWhereUniqueWithoutOwnerInput {
  where: OfficialDocumentWhereUniqueInput;
  update: OfficialDocumentUpdateWithoutOwnerDataInput;
  create: OfficialDocumentCreateWithoutOwnerInput;
}

export interface ItemUpdateManyDataInput {
  quantity?: Maybe<Int>;
  orderPrice?: Maybe<Float>;
}

export interface OfficialDocumentUpdateManyWithWhereNestedInput {
  where: OfficialDocumentScalarWhereInput;
  data: OfficialDocumentUpdateManyDataInput;
}

export interface ProductUpsertWithoutDiscountsInput {
  update: ProductUpdateWithoutDiscountsDataInput;
  create: ProductCreateWithoutDiscountsInput;
}

export interface SocialLinkUpdateManyWithoutOwnerInput {
  create?: Maybe<
    SocialLinkCreateWithoutOwnerInput[] | SocialLinkCreateWithoutOwnerInput
  >;
  delete?: Maybe<SocialLinkWhereUniqueInput[] | SocialLinkWhereUniqueInput>;
  connect?: Maybe<SocialLinkWhereUniqueInput[] | SocialLinkWhereUniqueInput>;
  set?: Maybe<SocialLinkWhereUniqueInput[] | SocialLinkWhereUniqueInput>;
  disconnect?: Maybe<SocialLinkWhereUniqueInput[] | SocialLinkWhereUniqueInput>;
  update?: Maybe<
    | SocialLinkUpdateWithWhereUniqueWithoutOwnerInput[]
    | SocialLinkUpdateWithWhereUniqueWithoutOwnerInput
  >;
  upsert?: Maybe<
    | SocialLinkUpsertWithWhereUniqueWithoutOwnerInput[]
    | SocialLinkUpsertWithWhereUniqueWithoutOwnerInput
  >;
  deleteMany?: Maybe<SocialLinkScalarWhereInput[] | SocialLinkScalarWhereInput>;
  updateMany?: Maybe<
    | SocialLinkUpdateManyWithWhereNestedInput[]
    | SocialLinkUpdateManyWithWhereNestedInput
  >;
}

export interface DiscountUpsertWithoutDiscountRequestsInput {
  update: DiscountUpdateWithoutDiscountRequestsDataInput;
  create: DiscountCreateWithoutDiscountRequestsInput;
}

export interface BranchWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  shortName?: Maybe<String>;
  shortName_not?: Maybe<String>;
  shortName_in?: Maybe<String[] | String>;
  shortName_not_in?: Maybe<String[] | String>;
  shortName_lt?: Maybe<String>;
  shortName_lte?: Maybe<String>;
  shortName_gt?: Maybe<String>;
  shortName_gte?: Maybe<String>;
  shortName_contains?: Maybe<String>;
  shortName_not_contains?: Maybe<String>;
  shortName_starts_with?: Maybe<String>;
  shortName_not_starts_with?: Maybe<String>;
  shortName_ends_with?: Maybe<String>;
  shortName_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  program?: Maybe<ProgramWhereInput>;
  subjects_every?: Maybe<SubjectWhereInput>;
  subjects_some?: Maybe<SubjectWhereInput>;
  subjects_none?: Maybe<SubjectWhereInput>;
  AND?: Maybe<BranchWhereInput[] | BranchWhereInput>;
  OR?: Maybe<BranchWhereInput[] | BranchWhereInput>;
  NOT?: Maybe<BranchWhereInput[] | BranchWhereInput>;
}

export interface DiscountRequestUpsertWithWhereUniqueWithoutUserInput {
  where: DiscountRequestWhereUniqueInput;
  update: DiscountRequestUpdateWithoutUserDataInput;
  create: DiscountRequestCreateWithoutUserInput;
}

export interface SubjectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SubjectWhereInput>;
  AND?: Maybe<SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput>;
  OR?: Maybe<SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput>;
  NOT?: Maybe<SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput>;
}

export interface UserUpsertWithoutEventsInput {
  update: UserUpdateWithoutEventsDataInput;
  create: UserCreateWithoutEventsInput;
}

export interface SocialLinkSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SocialLinkWhereInput>;
  AND?: Maybe<
    SocialLinkSubscriptionWhereInput[] | SocialLinkSubscriptionWhereInput
  >;
  OR?: Maybe<
    SocialLinkSubscriptionWhereInput[] | SocialLinkSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SocialLinkSubscriptionWhereInput[] | SocialLinkSubscriptionWhereInput
  >;
}

export interface EventUpsertWithWhereUniqueWithoutPlaceInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutPlaceDataInput;
  create: EventCreateWithoutPlaceInput;
}

export interface ProgramSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProgramWhereInput>;
  AND?: Maybe<ProgramSubscriptionWhereInput[] | ProgramSubscriptionWhereInput>;
  OR?: Maybe<ProgramSubscriptionWhereInput[] | ProgramSubscriptionWhereInput>;
  NOT?: Maybe<ProgramSubscriptionWhereInput[] | ProgramSubscriptionWhereInput>;
}

export interface EventScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  subtitle?: Maybe<String>;
  subtitle_not?: Maybe<String>;
  subtitle_in?: Maybe<String[] | String>;
  subtitle_not_in?: Maybe<String[] | String>;
  subtitle_lt?: Maybe<String>;
  subtitle_lte?: Maybe<String>;
  subtitle_gt?: Maybe<String>;
  subtitle_gte?: Maybe<String>;
  subtitle_contains?: Maybe<String>;
  subtitle_not_contains?: Maybe<String>;
  subtitle_starts_with?: Maybe<String>;
  subtitle_not_starts_with?: Maybe<String>;
  subtitle_ends_with?: Maybe<String>;
  subtitle_not_ends_with?: Maybe<String>;
  organizer?: Maybe<String>;
  organizer_not?: Maybe<String>;
  organizer_in?: Maybe<String[] | String>;
  organizer_not_in?: Maybe<String[] | String>;
  organizer_lt?: Maybe<String>;
  organizer_lte?: Maybe<String>;
  organizer_gt?: Maybe<String>;
  organizer_gte?: Maybe<String>;
  organizer_contains?: Maybe<String>;
  organizer_not_contains?: Maybe<String>;
  organizer_starts_with?: Maybe<String>;
  organizer_not_starts_with?: Maybe<String>;
  organizer_ends_with?: Maybe<String>;
  organizer_not_ends_with?: Maybe<String>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  imageURL?: Maybe<String>;
  imageURL_not?: Maybe<String>;
  imageURL_in?: Maybe<String[] | String>;
  imageURL_not_in?: Maybe<String[] | String>;
  imageURL_lt?: Maybe<String>;
  imageURL_lte?: Maybe<String>;
  imageURL_gt?: Maybe<String>;
  imageURL_gte?: Maybe<String>;
  imageURL_contains?: Maybe<String>;
  imageURL_not_contains?: Maybe<String>;
  imageURL_starts_with?: Maybe<String>;
  imageURL_not_starts_with?: Maybe<String>;
  imageURL_ends_with?: Maybe<String>;
  imageURL_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  access?: Maybe<String>;
  access_not?: Maybe<String>;
  access_in?: Maybe<String[] | String>;
  access_not_in?: Maybe<String[] | String>;
  access_lt?: Maybe<String>;
  access_lte?: Maybe<String>;
  access_gt?: Maybe<String>;
  access_gte?: Maybe<String>;
  access_contains?: Maybe<String>;
  access_not_contains?: Maybe<String>;
  access_starts_with?: Maybe<String>;
  access_not_starts_with?: Maybe<String>;
  access_ends_with?: Maybe<String>;
  access_not_ends_with?: Maybe<String>;
  accessPoint?: Maybe<String>;
  accessPoint_not?: Maybe<String>;
  accessPoint_in?: Maybe<String[] | String>;
  accessPoint_not_in?: Maybe<String[] | String>;
  accessPoint_lt?: Maybe<String>;
  accessPoint_lte?: Maybe<String>;
  accessPoint_gt?: Maybe<String>;
  accessPoint_gte?: Maybe<String>;
  accessPoint_contains?: Maybe<String>;
  accessPoint_not_contains?: Maybe<String>;
  accessPoint_starts_with?: Maybe<String>;
  accessPoint_not_starts_with?: Maybe<String>;
  accessPoint_ends_with?: Maybe<String>;
  accessPoint_not_ends_with?: Maybe<String>;
  target?: Maybe<UserGroup>;
  target_not?: Maybe<UserGroup>;
  target_in?: Maybe<UserGroup[] | UserGroup>;
  target_not_in?: Maybe<UserGroup[] | UserGroup>;
  status?: Maybe<AppNodeStatus>;
  status_not?: Maybe<AppNodeStatus>;
  status_in?: Maybe<AppNodeStatus[] | AppNodeStatus>;
  status_not_in?: Maybe<AppNodeStatus[] | AppNodeStatus>;
  AND?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  OR?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  NOT?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
}

export interface OrderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrderWhereInput>;
  AND?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  OR?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  NOT?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
}

export interface EventUpdateManyWithWhereNestedInput {
  where: EventScalarWhereInput;
  data: EventUpdateManyDataInput;
}

export interface NewsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NewsWhereInput>;
  AND?: Maybe<NewsSubscriptionWhereInput[] | NewsSubscriptionWhereInput>;
  OR?: Maybe<NewsSubscriptionWhereInput[] | NewsSubscriptionWhereInput>;
  NOT?: Maybe<NewsSubscriptionWhereInput[] | NewsSubscriptionWhereInput>;
}

export interface EventUpdateManyDataInput {
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  organizer?: Maybe<String>;
  body?: Maybe<String>;
  imageURL?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  access?: Maybe<String>;
  accessPoint?: Maybe<String>;
  target?: Maybe<UserGroup>;
  status?: Maybe<AppNodeStatus>;
}

export interface DepartmentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  members_every?: Maybe<UserWhereInput>;
  members_some?: Maybe<UserWhereInput>;
  members_none?: Maybe<UserWhereInput>;
  AND?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
  OR?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
  NOT?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
}

export interface SpaceUpsertWithoutSessionsInput {
  update: SpaceUpdateWithoutSessionsDataInput;
  create: SpaceCreateWithoutSessionsInput;
}

export interface DiscountSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DiscountWhereInput>;
  AND?: Maybe<
    DiscountSubscriptionWhereInput[] | DiscountSubscriptionWhereInput
  >;
  OR?: Maybe<DiscountSubscriptionWhereInput[] | DiscountSubscriptionWhereInput>;
  NOT?: Maybe<
    DiscountSubscriptionWhereInput[] | DiscountSubscriptionWhereInput
  >;
}

export interface SessionUpsertWithWhereUniqueWithoutByInput {
  where: SessionWhereUniqueInput;
  update: SessionUpdateWithoutByDataInput;
  create: SessionCreateWithoutByInput;
}

export interface DeviceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DeviceWhereInput>;
  AND?: Maybe<DeviceSubscriptionWhereInput[] | DeviceSubscriptionWhereInput>;
  OR?: Maybe<DeviceSubscriptionWhereInput[] | DeviceSubscriptionWhereInput>;
  NOT?: Maybe<DeviceSubscriptionWhereInput[] | DeviceSubscriptionWhereInput>;
}

export interface SessionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  closedAt?: Maybe<DateTimeInput>;
  closedAt_not?: Maybe<DateTimeInput>;
  closedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  closedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  closedAt_lt?: Maybe<DateTimeInput>;
  closedAt_lte?: Maybe<DateTimeInput>;
  closedAt_gt?: Maybe<DateTimeInput>;
  closedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SessionScalarWhereInput[] | SessionScalarWhereInput>;
  OR?: Maybe<SessionScalarWhereInput[] | SessionScalarWhereInput>;
  NOT?: Maybe<SessionScalarWhereInput[] | SessionScalarWhereInput>;
}

export interface AddressSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AddressWhereInput>;
  AND?: Maybe<AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput>;
  OR?: Maybe<AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput>;
  NOT?: Maybe<AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput>;
}

export interface SessionUpdateManyWithWhereNestedInput {
  where: SessionScalarWhereInput;
  data: SessionUpdateManyDataInput;
}

export type BranchWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
  shortName?: Maybe<String>;
}>;

export interface SessionUpdateManyDataInput {
  closedAt?: Maybe<DateTimeInput>;
}

export type DepartmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpsertWithWhereUniqueWithoutAvailableLessonsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutAvailableLessonsDataInput;
  create: UserCreateWithoutAvailableLessonsInput;
}

export interface VenueUpdateInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  placeID?: Maybe<String>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  spaces?: Maybe<SpaceUpdateManyWithoutVenueInput>;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  firstname?: Maybe<String>;
  firstname_not?: Maybe<String>;
  firstname_in?: Maybe<String[] | String>;
  firstname_not_in?: Maybe<String[] | String>;
  firstname_lt?: Maybe<String>;
  firstname_lte?: Maybe<String>;
  firstname_gt?: Maybe<String>;
  firstname_gte?: Maybe<String>;
  firstname_contains?: Maybe<String>;
  firstname_not_contains?: Maybe<String>;
  firstname_starts_with?: Maybe<String>;
  firstname_not_starts_with?: Maybe<String>;
  firstname_ends_with?: Maybe<String>;
  firstname_not_ends_with?: Maybe<String>;
  lastname?: Maybe<String>;
  lastname_not?: Maybe<String>;
  lastname_in?: Maybe<String[] | String>;
  lastname_not_in?: Maybe<String[] | String>;
  lastname_lt?: Maybe<String>;
  lastname_lte?: Maybe<String>;
  lastname_gt?: Maybe<String>;
  lastname_gte?: Maybe<String>;
  lastname_contains?: Maybe<String>;
  lastname_not_contains?: Maybe<String>;
  lastname_starts_with?: Maybe<String>;
  lastname_not_starts_with?: Maybe<String>;
  lastname_ends_with?: Maybe<String>;
  lastname_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  emailVerified_not?: Maybe<Boolean>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  group?: Maybe<UserGroup>;
  group_not?: Maybe<UserGroup>;
  group_in?: Maybe<UserGroup[] | UserGroup>;
  group_not_in?: Maybe<UserGroup[] | UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  groupRequest_not?: Maybe<UserGroup>;
  groupRequest_in?: Maybe<UserGroup[] | UserGroup>;
  groupRequest_not_in?: Maybe<UserGroup[] | UserGroup>;
  isAdmin?: Maybe<Boolean>;
  isAdmin_not?: Maybe<Boolean>;
  avatar?: Maybe<String>;
  avatar_not?: Maybe<String>;
  avatar_in?: Maybe<String[] | String>;
  avatar_not_in?: Maybe<String[] | String>;
  avatar_lt?: Maybe<String>;
  avatar_lte?: Maybe<String>;
  avatar_gt?: Maybe<String>;
  avatar_gte?: Maybe<String>;
  avatar_contains?: Maybe<String>;
  avatar_not_contains?: Maybe<String>;
  avatar_starts_with?: Maybe<String>;
  avatar_not_starts_with?: Maybe<String>;
  avatar_ends_with?: Maybe<String>;
  avatar_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface VenueCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  address: String;
  placeID?: Maybe<String>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  spaces?: Maybe<SpaceCreateManyWithoutVenueInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface TransactionUpdateManyMutationInput {
  type?: Maybe<TxType>;
  reference?: Maybe<String>;
  amount?: Maybe<Int>;
}

export interface UserUpdateManyDataInput {
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  email?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  password?: Maybe<String>;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  avatar?: Maybe<String>;
  metadata?: Maybe<Json>;
}

export interface OrderUpdateOneWithoutTransactionsInput {
  create?: Maybe<OrderCreateWithoutTransactionsInput>;
  update?: Maybe<OrderUpdateWithoutTransactionsDataInput>;
  upsert?: Maybe<OrderUpsertWithoutTransactionsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface LessonUpsertWithWhereUniqueWithoutManagerInput {
  where: LessonWhereUniqueInput;
  update: LessonUpdateWithoutManagerDataInput;
  create: LessonCreateWithoutManagerInput;
}

export interface OrderCreateOneWithoutTransactionsInput {
  create?: Maybe<OrderCreateWithoutTransactionsInput>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface LessonScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<LessonScalarWhereInput[] | LessonScalarWhereInput>;
  OR?: Maybe<LessonScalarWhereInput[] | LessonScalarWhereInput>;
  NOT?: Maybe<LessonScalarWhereInput[] | LessonScalarWhereInput>;
}

export interface SubjectUpdateInput {
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  description?: Maybe<String>;
  branch?: Maybe<BranchUpdateOneRequiredWithoutSubjectsInput>;
  lesson?: Maybe<LessonUpdateOneWithoutSubjectsInput>;
}

export interface LessonUpdateManyWithWhereNestedInput {
  where: LessonScalarWhereInput;
  data: LessonUpdateManyDataInput;
}

export interface SpaceUpdateInput {
  name?: Maybe<String>;
  venue?: Maybe<VenueUpdateOneRequiredWithoutSpacesInput>;
  events?: Maybe<EventUpdateManyWithoutPlaceInput>;
  sessions?: Maybe<SessionUpdateManyWithoutAtInput>;
}

export interface LessonUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface SocialLinkUpsertWithWhereUniqueWithoutSocialNetworkInput {
  where: SocialLinkWhereUniqueInput;
  update: SocialLinkUpdateWithoutSocialNetworkDataInput;
  create: SocialLinkCreateWithoutSocialNetworkInput;
}

export interface UserUpsertWithoutTeachedSessionsInput {
  update: UserUpdateWithoutTeachedSessionsDataInput;
  create: UserCreateWithoutTeachedSessionsInput;
}

export interface SocialLinkUpdateManyWithoutSocialNetworkInput {
  create?: Maybe<
    | SocialLinkCreateWithoutSocialNetworkInput[]
    | SocialLinkCreateWithoutSocialNetworkInput
  >;
  delete?: Maybe<SocialLinkWhereUniqueInput[] | SocialLinkWhereUniqueInput>;
  connect?: Maybe<SocialLinkWhereUniqueInput[] | SocialLinkWhereUniqueInput>;
  set?: Maybe<SocialLinkWhereUniqueInput[] | SocialLinkWhereUniqueInput>;
  disconnect?: Maybe<SocialLinkWhereUniqueInput[] | SocialLinkWhereUniqueInput>;
  update?: Maybe<
    | SocialLinkUpdateWithWhereUniqueWithoutSocialNetworkInput[]
    | SocialLinkUpdateWithWhereUniqueWithoutSocialNetworkInput
  >;
  upsert?: Maybe<
    | SocialLinkUpsertWithWhereUniqueWithoutSocialNetworkInput[]
    | SocialLinkUpsertWithWhereUniqueWithoutSocialNetworkInput
  >;
  deleteMany?: Maybe<SocialLinkScalarWhereInput[] | SocialLinkScalarWhereInput>;
  updateMany?: Maybe<
    | SocialLinkUpdateManyWithWhereNestedInput[]
    | SocialLinkUpdateManyWithWhereNestedInput
  >;
}

export interface SessionUpsertWithWhereUniqueWithoutLessonInput {
  where: SessionWhereUniqueInput;
  update: SessionUpdateWithoutLessonDataInput;
  create: SessionCreateWithoutLessonInput;
}

export interface SocialLinkCreateWithoutSocialNetworkInput {
  id?: Maybe<ID_Input>;
  link: String;
  owner: UserCreateOneWithoutSocialNetworkLinksInput;
}

export interface LessonUpsertWithWhereUniqueWithoutAvailableTeachersInput {
  where: LessonWhereUniqueInput;
  update: LessonUpdateWithoutAvailableTeachersDataInput;
  create: LessonCreateWithoutAvailableTeachersInput;
}

export interface SocialNetworkCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  baseURL: String;
  ownURL: String;
  userLinks?: Maybe<SocialLinkCreateManyWithoutSocialNetworkInput>;
}

export interface UserUpsertWithoutLessonsManagedInput {
  update: UserUpdateWithoutLessonsManagedDataInput;
  create: UserCreateWithoutLessonsManagedInput;
}

export interface UserUpdateWithoutSocialNetworkLinksDataInput {
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  email?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  password?: Maybe<String>;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleUpdateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressUpdateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceUpdateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentUpdateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  newses?: Maybe<NewsUpdateManyWithoutAuthorInput>;
  events?: Maybe<EventUpdateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonUpdateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonUpdateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionUpdateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestUpdateManyWithoutUserInput>;
}

export interface LessonUpsertWithoutSessionsInput {
  update: LessonUpdateWithoutSessionsDataInput;
  create: LessonCreateWithoutSessionsInput;
}

export interface UserCreateWithoutSocialNetworkLinksInput {
  id?: Maybe<ID_Input>;
  firstname: String;
  lastname: String;
  email: String;
  emailVerified?: Maybe<Boolean>;
  password: String;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleCreateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressCreateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceCreateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentCreateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  newses?: Maybe<NewsCreateManyWithoutAuthorInput>;
  events?: Maybe<EventCreateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonCreateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonCreateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionCreateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestCreateManyWithoutUserInput>;
}

export interface SessionUpsertWithWhereUniqueWithoutAtInput {
  where: SessionWhereUniqueInput;
  update: SessionUpdateWithoutAtDataInput;
  create: SessionCreateWithoutAtInput;
}

export type ProgramWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
  shortName?: Maybe<String>;
}>;

export interface SpaceUpsertWithoutEventsInput {
  update: SpaceUpdateWithoutEventsDataInput;
  create: SpaceCreateWithoutEventsInput;
}

export interface UserUpsertWithWhereUniqueWithoutRolesInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutRolesDataInput;
  create: UserCreateWithoutRolesInput;
}

export interface EventUpsertWithWhereUniqueWithoutAuthorInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutAuthorDataInput;
  create: EventCreateWithoutAuthorInput;
}

export interface UserUpdateManyWithoutRolesInput {
  create?: Maybe<UserCreateWithoutRolesInput[] | UserCreateWithoutRolesInput>;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutRolesInput[]
    | UserUpdateWithWhereUniqueWithoutRolesInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutRolesInput[]
    | UserUpsertWithWhereUniqueWithoutRolesInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpsertWithoutAddressesInput {
  update: UserUpdateWithoutAddressesDataInput;
  create: UserCreateWithoutAddressesInput;
}

export interface UserCreateManyWithoutRolesInput {
  create?: Maybe<UserCreateWithoutRolesInput[] | UserCreateWithoutRolesInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface AddressUpdateManyMutationInput {
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  region?: Maybe<String>;
  country?: Maybe<String>;
  code?: Maybe<String>;
  primary?: Maybe<Boolean>;
}

export interface BranchUpdateManyDataInput {
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  description?: Maybe<String>;
}

export interface ProductUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  content?: Maybe<String>;
  unitPrice?: Maybe<Float>;
  imageURLs?: Maybe<ProductUpdateimageURLsInput>;
}

export interface BranchUpsertWithWhereUniqueWithoutProgramInput {
  where: BranchWhereUniqueInput;
  update: BranchUpdateWithoutProgramDataInput;
  create: BranchCreateWithoutProgramInput;
}

export interface ProductUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  content?: Maybe<String>;
  unitPrice?: Maybe<Float>;
  category?: Maybe<ProductCategoryUpdateOneRequiredWithoutProductsInput>;
  imageURLs?: Maybe<ProductUpdateimageURLsInput>;
  discounts?: Maybe<DiscountUpdateManyWithoutProductInput>;
  orders?: Maybe<ItemUpdateManyWithoutProductInput>;
}

export interface BranchUpdateManyWithoutProgramInput {
  create?: Maybe<
    BranchCreateWithoutProgramInput[] | BranchCreateWithoutProgramInput
  >;
  delete?: Maybe<BranchWhereUniqueInput[] | BranchWhereUniqueInput>;
  connect?: Maybe<BranchWhereUniqueInput[] | BranchWhereUniqueInput>;
  set?: Maybe<BranchWhereUniqueInput[] | BranchWhereUniqueInput>;
  disconnect?: Maybe<BranchWhereUniqueInput[] | BranchWhereUniqueInput>;
  update?: Maybe<
    | BranchUpdateWithWhereUniqueWithoutProgramInput[]
    | BranchUpdateWithWhereUniqueWithoutProgramInput
  >;
  upsert?: Maybe<
    | BranchUpsertWithWhereUniqueWithoutProgramInput[]
    | BranchUpsertWithWhereUniqueWithoutProgramInput
  >;
  deleteMany?: Maybe<BranchScalarWhereInput[] | BranchScalarWhereInput>;
  updateMany?: Maybe<
    | BranchUpdateManyWithWhereNestedInput[]
    | BranchUpdateManyWithWhereNestedInput
  >;
}

export interface BranchCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  shortName: String;
  description?: Maybe<String>;
  program: ProgramCreateOneWithoutBranchesInput;
  subjects?: Maybe<SubjectCreateManyWithoutBranchInput>;
}

export interface BranchCreateManyWithoutProgramInput {
  create?: Maybe<
    BranchCreateWithoutProgramInput[] | BranchCreateWithoutProgramInput
  >;
  connect?: Maybe<BranchWhereUniqueInput[] | BranchWhereUniqueInput>;
}

export interface SubjectCreateManyWithoutBranchInput {
  create?: Maybe<
    SubjectCreateWithoutBranchInput[] | SubjectCreateWithoutBranchInput
  >;
  connect?: Maybe<SubjectWhereUniqueInput[] | SubjectWhereUniqueInput>;
}

export interface ProductUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  content?: Maybe<String>;
  unitPrice?: Maybe<Float>;
  imageURLs?: Maybe<ProductUpdateimageURLsInput>;
}

export interface SubjectCreateWithoutBranchInput {
  id?: Maybe<ID_Input>;
  name: String;
  shortName: String;
  description?: Maybe<String>;
  lesson?: Maybe<LessonCreateOneWithoutSubjectsInput>;
}

export interface ProductUpsertWithWhereUniqueWithoutCategoryInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutCategoryDataInput;
  create: ProductCreateWithoutCategoryInput;
}

export interface LessonCreateOneWithoutSubjectsInput {
  create?: Maybe<LessonCreateWithoutSubjectsInput>;
  connect?: Maybe<LessonWhereUniqueInput>;
}

export interface ProductUpdateManyWithoutCategoryInput {
  create?: Maybe<
    ProductCreateWithoutCategoryInput[] | ProductCreateWithoutCategoryInput
  >;
  delete?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  set?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  disconnect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  update?: Maybe<
    | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    | ProductUpdateWithWhereUniqueWithoutCategoryInput
  >;
  upsert?: Maybe<
    | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    | ProductUpsertWithWhereUniqueWithoutCategoryInput
  >;
  deleteMany?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  updateMany?: Maybe<
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput
  >;
}

export interface LessonCreateWithoutSubjectsInput {
  id?: Maybe<ID_Input>;
  name: String;
  period: OperatingPeriodCreateOneWithoutLessonsInput;
  sessions?: Maybe<SessionCreateManyWithoutLessonInput>;
  manager: UserCreateOneWithoutLessonsManagedInput;
  availableTeachers?: Maybe<UserCreateManyWithoutAvailableLessonsInput>;
}

export interface AddressCreateInput {
  id?: Maybe<ID_Input>;
  owner?: Maybe<UserCreateOneWithoutAddressesInput>;
  address1: String;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  region: String;
  country: String;
  code: String;
  primary?: Maybe<Boolean>;
}

export interface BranchUpdateInput {
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  description?: Maybe<String>;
  program?: Maybe<ProgramUpdateOneRequiredWithoutBranchesInput>;
  subjects?: Maybe<SubjectUpdateManyWithoutBranchInput>;
}

export interface RoleCreateWithoutUsersInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface SubjectUpdateManyWithoutBranchInput {
  create?: Maybe<
    SubjectCreateWithoutBranchInput[] | SubjectCreateWithoutBranchInput
  >;
  delete?: Maybe<SubjectWhereUniqueInput[] | SubjectWhereUniqueInput>;
  connect?: Maybe<SubjectWhereUniqueInput[] | SubjectWhereUniqueInput>;
  set?: Maybe<SubjectWhereUniqueInput[] | SubjectWhereUniqueInput>;
  disconnect?: Maybe<SubjectWhereUniqueInput[] | SubjectWhereUniqueInput>;
  update?: Maybe<
    | SubjectUpdateWithWhereUniqueWithoutBranchInput[]
    | SubjectUpdateWithWhereUniqueWithoutBranchInput
  >;
  upsert?: Maybe<
    | SubjectUpsertWithWhereUniqueWithoutBranchInput[]
    | SubjectUpsertWithWhereUniqueWithoutBranchInput
  >;
  deleteMany?: Maybe<SubjectScalarWhereInput[] | SubjectScalarWhereInput>;
  updateMany?: Maybe<
    | SubjectUpdateManyWithWhereNestedInput[]
    | SubjectUpdateManyWithWhereNestedInput
  >;
}

export interface OfficialDocumentCreateWithoutOwnerInput {
  id?: Maybe<ID_Input>;
  number: String;
  type?: Maybe<OfficialDocumentType>;
  other?: Maybe<String>;
  expiration?: Maybe<DateTimeInput>;
}

export interface SubjectUpdateWithWhereUniqueWithoutBranchInput {
  where: SubjectWhereUniqueInput;
  data: SubjectUpdateWithoutBranchDataInput;
}

export interface SocialNetworkCreateWithoutUserLinksInput {
  id?: Maybe<ID_Input>;
  name: String;
  baseURL: String;
  ownURL: String;
}

export interface SubjectUpdateWithoutBranchDataInput {
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  description?: Maybe<String>;
  lesson?: Maybe<LessonUpdateOneWithoutSubjectsInput>;
}

export interface NewsCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  title: String;
  subtitle?: Maybe<String>;
  body: String;
  imageURL?: Maybe<String>;
  expiration?: Maybe<DateTimeInput>;
  category?: Maybe<String>;
  featured?: Maybe<Boolean>;
  target: UserGroup;
  status?: Maybe<AppNodeStatus>;
}

export interface LessonUpdateOneWithoutSubjectsInput {
  create?: Maybe<LessonCreateWithoutSubjectsInput>;
  update?: Maybe<LessonUpdateWithoutSubjectsDataInput>;
  upsert?: Maybe<LessonUpsertWithoutSubjectsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<LessonWhereUniqueInput>;
}

export interface SpaceCreateWithoutEventsInput {
  id?: Maybe<ID_Input>;
  name: String;
  venue: VenueCreateOneWithoutSpacesInput;
  sessions?: Maybe<SessionCreateManyWithoutAtInput>;
}

export interface LessonUpdateWithoutSubjectsDataInput {
  name?: Maybe<String>;
  period?: Maybe<OperatingPeriodUpdateOneRequiredWithoutLessonsInput>;
  sessions?: Maybe<SessionUpdateManyWithoutLessonInput>;
  manager?: Maybe<UserUpdateOneRequiredWithoutLessonsManagedInput>;
  availableTeachers?: Maybe<UserUpdateManyWithoutAvailableLessonsInput>;
}

export interface SessionCreateWithoutAtInput {
  id?: Maybe<ID_Input>;
  lesson: LessonCreateOneWithoutSessionsInput;
  closedAt: DateTimeInput;
  by: UserCreateOneWithoutTeachedSessionsInput;
}

export interface LessonUpsertWithoutSubjectsInput {
  update: LessonUpdateWithoutSubjectsDataInput;
  create: LessonCreateWithoutSubjectsInput;
}

export interface SubjectCreateWithoutLessonInput {
  id?: Maybe<ID_Input>;
  name: String;
  shortName: String;
  description?: Maybe<String>;
  branch: BranchCreateOneWithoutSubjectsInput;
}

export interface SubjectUpsertWithWhereUniqueWithoutBranchInput {
  where: SubjectWhereUniqueInput;
  update: SubjectUpdateWithoutBranchDataInput;
  create: SubjectCreateWithoutBranchInput;
}

export interface ProgramCreateWithoutBranchesInput {
  id?: Maybe<ID_Input>;
  name: String;
  shortName: String;
  description?: Maybe<String>;
}

export interface BranchUpdateManyMutationInput {
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  description?: Maybe<String>;
}

export interface UserCreateWithoutLessonsManagedInput {
  id?: Maybe<ID_Input>;
  firstname: String;
  lastname: String;
  email: String;
  emailVerified?: Maybe<Boolean>;
  password: String;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleCreateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressCreateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceCreateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentCreateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkCreateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  newses?: Maybe<NewsCreateManyWithoutAuthorInput>;
  events?: Maybe<EventCreateManyWithoutAuthorInput>;
  availableLessons?: Maybe<LessonCreateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionCreateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestCreateManyWithoutUserInput>;
}

export interface DepartmentCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  members?: Maybe<UserCreateManyWithoutDepartmentInput>;
}

export interface LessonCreateWithoutAvailableTeachersInput {
  id?: Maybe<ID_Input>;
  name: String;
  subjects?: Maybe<SubjectCreateManyWithoutLessonInput>;
  period: OperatingPeriodCreateOneWithoutLessonsInput;
  sessions?: Maybe<SessionCreateManyWithoutLessonInput>;
  manager: UserCreateOneWithoutLessonsManagedInput;
}

export interface UserCreateManyWithoutDepartmentInput {
  create?: Maybe<
    UserCreateWithoutDepartmentInput[] | UserCreateWithoutDepartmentInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutTeachedSessionsInput {
  id?: Maybe<ID_Input>;
  firstname: String;
  lastname: String;
  email: String;
  emailVerified?: Maybe<Boolean>;
  password: String;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleCreateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressCreateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceCreateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentCreateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkCreateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  newses?: Maybe<NewsCreateManyWithoutAuthorInput>;
  events?: Maybe<EventCreateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonCreateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonCreateManyWithoutAvailableTeachersInput>;
  discountRequests?: Maybe<DiscountRequestCreateManyWithoutUserInput>;
}

export interface UserCreateWithoutDepartmentInput {
  id?: Maybe<ID_Input>;
  firstname: String;
  lastname: String;
  email: String;
  emailVerified?: Maybe<Boolean>;
  password: String;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleCreateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressCreateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceCreateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentCreateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkCreateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  newses?: Maybe<NewsCreateManyWithoutAuthorInput>;
  events?: Maybe<EventCreateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonCreateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonCreateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionCreateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestCreateManyWithoutUserInput>;
}

export interface UserCreateWithoutAvailableLessonsInput {
  id?: Maybe<ID_Input>;
  firstname: String;
  lastname: String;
  email: String;
  emailVerified?: Maybe<Boolean>;
  password: String;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleCreateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressCreateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceCreateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentCreateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkCreateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  newses?: Maybe<NewsCreateManyWithoutAuthorInput>;
  events?: Maybe<EventCreateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonCreateManyWithoutManagerInput>;
  teachedSessions?: Maybe<SessionCreateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestCreateManyWithoutUserInput>;
}

export interface DepartmentUpdateInput {
  name?: Maybe<String>;
  members?: Maybe<UserUpdateManyWithoutDepartmentInput>;
}

export interface SpaceCreateWithoutSessionsInput {
  id?: Maybe<ID_Input>;
  name: String;
  venue: VenueCreateOneWithoutSpacesInput;
  events?: Maybe<EventCreateManyWithoutPlaceInput>;
}

export interface UserUpdateManyWithoutDepartmentInput {
  create?: Maybe<
    UserCreateWithoutDepartmentInput[] | UserCreateWithoutDepartmentInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutDepartmentInput[]
    | UserUpdateWithWhereUniqueWithoutDepartmentInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutDepartmentInput[]
    | UserUpsertWithWhereUniqueWithoutDepartmentInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateWithoutEventsInput {
  id?: Maybe<ID_Input>;
  firstname: String;
  lastname: String;
  email: String;
  emailVerified?: Maybe<Boolean>;
  password: String;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleCreateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressCreateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceCreateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentCreateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkCreateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  newses?: Maybe<NewsCreateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonCreateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonCreateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionCreateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestCreateManyWithoutUserInput>;
}

export interface UserUpdateWithWhereUniqueWithoutDepartmentInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutDepartmentDataInput;
}

export interface DiscountCreateWithoutDiscountRequestsInput {
  id?: Maybe<ID_Input>;
  product: ProductCreateOneWithoutDiscountsInput;
  name: String;
  description: String;
  code?: Maybe<String>;
  unitPrice: Float;
  requirements: String;
}

export interface UserUpdateWithoutDepartmentDataInput {
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  email?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  password?: Maybe<String>;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleUpdateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressUpdateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceUpdateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentUpdateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkUpdateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  newses?: Maybe<NewsUpdateManyWithoutAuthorInput>;
  events?: Maybe<EventUpdateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonUpdateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonUpdateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionUpdateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestUpdateManyWithoutUserInput>;
}

export interface ProductCategoryCreateWithoutProductsInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface UserUpsertWithWhereUniqueWithoutDepartmentInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutDepartmentDataInput;
  create: UserCreateWithoutDepartmentInput;
}

export interface OrderCreateOneWithoutItemsInput {
  create?: Maybe<OrderCreateWithoutItemsInput>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface DepartmentUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface TransactionCreateManyWithoutOrderInput {
  create?: Maybe<
    TransactionCreateWithoutOrderInput[] | TransactionCreateWithoutOrderInput
  >;
  connect?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
}

export interface DeviceCreateInput {
  id?: Maybe<ID_Input>;
  owner?: Maybe<UserCreateOneWithoutDevicesInput>;
  countryCode?: Maybe<String>;
  number?: Maybe<String>;
  type?: Maybe<DeviceType>;
  notificationsDevice?: Maybe<String>;
  notificationsPermission?: Maybe<Boolean>;
  verified?: Maybe<Boolean>;
}

export interface DiscountRequestCreateManyWithoutDiscountInput {
  create?: Maybe<
    | DiscountRequestCreateWithoutDiscountInput[]
    | DiscountRequestCreateWithoutDiscountInput
  >;
  connect?: Maybe<
    DiscountRequestWhereUniqueInput[] | DiscountRequestWhereUniqueInput
  >;
}

export interface UserCreateOneWithoutDevicesInput {
  create?: Maybe<UserCreateWithoutDevicesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface DiscountRequestCreatedocumentationInput {
  set?: Maybe<String[] | String>;
}

export interface UserCreateWithoutDevicesInput {
  id?: Maybe<ID_Input>;
  firstname: String;
  lastname: String;
  email: String;
  emailVerified?: Maybe<Boolean>;
  password: String;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleCreateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressCreateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentCreateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkCreateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  newses?: Maybe<NewsCreateManyWithoutAuthorInput>;
  events?: Maybe<EventCreateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonCreateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonCreateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionCreateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestCreateManyWithoutUserInput>;
}

export interface RoleUpdateManyWithoutUsersInput {
  create?: Maybe<RoleCreateWithoutUsersInput[] | RoleCreateWithoutUsersInput>;
  delete?: Maybe<RoleWhereUniqueInput[] | RoleWhereUniqueInput>;
  connect?: Maybe<RoleWhereUniqueInput[] | RoleWhereUniqueInput>;
  set?: Maybe<RoleWhereUniqueInput[] | RoleWhereUniqueInput>;
  disconnect?: Maybe<RoleWhereUniqueInput[] | RoleWhereUniqueInput>;
  update?: Maybe<
    | RoleUpdateWithWhereUniqueWithoutUsersInput[]
    | RoleUpdateWithWhereUniqueWithoutUsersInput
  >;
  upsert?: Maybe<
    | RoleUpsertWithWhereUniqueWithoutUsersInput[]
    | RoleUpsertWithWhereUniqueWithoutUsersInput
  >;
  deleteMany?: Maybe<RoleScalarWhereInput[] | RoleScalarWhereInput>;
  updateMany?: Maybe<
    RoleUpdateManyWithWhereNestedInput[] | RoleUpdateManyWithWhereNestedInput
  >;
}

export interface DeviceUpdateInput {
  owner?: Maybe<UserUpdateOneWithoutDevicesInput>;
  countryCode?: Maybe<String>;
  number?: Maybe<String>;
  type?: Maybe<DeviceType>;
  notificationsDevice?: Maybe<String>;
  notificationsPermission?: Maybe<Boolean>;
  verified?: Maybe<Boolean>;
}

export interface RoleScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<RoleScalarWhereInput[] | RoleScalarWhereInput>;
  OR?: Maybe<RoleScalarWhereInput[] | RoleScalarWhereInput>;
  NOT?: Maybe<RoleScalarWhereInput[] | RoleScalarWhereInput>;
}

export interface UserUpdateOneWithoutDevicesInput {
  create?: Maybe<UserCreateWithoutDevicesInput>;
  update?: Maybe<UserUpdateWithoutDevicesDataInput>;
  upsert?: Maybe<UserUpsertWithoutDevicesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface DeviceUpdateWithWhereUniqueWithoutOwnerInput {
  where: DeviceWhereUniqueInput;
  data: DeviceUpdateWithoutOwnerDataInput;
}

export interface UserUpdateWithoutDevicesDataInput {
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  email?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  password?: Maybe<String>;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleUpdateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressUpdateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentUpdateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkUpdateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  newses?: Maybe<NewsUpdateManyWithoutAuthorInput>;
  events?: Maybe<EventUpdateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonUpdateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonUpdateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionUpdateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestUpdateManyWithoutUserInput>;
}

export interface DeviceUpdateManyWithWhereNestedInput {
  where: DeviceScalarWhereInput;
  data: DeviceUpdateManyDataInput;
}

export interface UserUpsertWithoutDevicesInput {
  update: UserUpdateWithoutDevicesDataInput;
  create: UserCreateWithoutDevicesInput;
}

export interface OfficialDocumentUpdateWithoutOwnerDataInput {
  number?: Maybe<String>;
  type?: Maybe<OfficialDocumentType>;
  other?: Maybe<String>;
  expiration?: Maybe<DateTimeInput>;
}

export interface DeviceUpdateManyMutationInput {
  countryCode?: Maybe<String>;
  number?: Maybe<String>;
  type?: Maybe<DeviceType>;
  notificationsDevice?: Maybe<String>;
  notificationsPermission?: Maybe<Boolean>;
  verified?: Maybe<Boolean>;
}

export interface OfficialDocumentUpdateManyDataInput {
  number?: Maybe<String>;
  type?: Maybe<OfficialDocumentType>;
  other?: Maybe<String>;
  expiration?: Maybe<DateTimeInput>;
}

export interface DiscountUpdateInput {
  product?: Maybe<ProductUpdateOneRequiredWithoutDiscountsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  code?: Maybe<String>;
  unitPrice?: Maybe<Float>;
  discountRequests?: Maybe<DiscountRequestUpdateManyWithoutDiscountInput>;
  requirements?: Maybe<String>;
}

export interface SubjectWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  shortName?: Maybe<String>;
  shortName_not?: Maybe<String>;
  shortName_in?: Maybe<String[] | String>;
  shortName_not_in?: Maybe<String[] | String>;
  shortName_lt?: Maybe<String>;
  shortName_lte?: Maybe<String>;
  shortName_gt?: Maybe<String>;
  shortName_gte?: Maybe<String>;
  shortName_contains?: Maybe<String>;
  shortName_not_contains?: Maybe<String>;
  shortName_starts_with?: Maybe<String>;
  shortName_not_starts_with?: Maybe<String>;
  shortName_ends_with?: Maybe<String>;
  shortName_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  branch?: Maybe<BranchWhereInput>;
  lesson?: Maybe<LessonWhereInput>;
  AND?: Maybe<SubjectWhereInput[] | SubjectWhereInput>;
  OR?: Maybe<SubjectWhereInput[] | SubjectWhereInput>;
  NOT?: Maybe<SubjectWhereInput[] | SubjectWhereInput>;
}

export interface DiscountUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  code?: Maybe<String>;
  unitPrice?: Maybe<Float>;
  requirements?: Maybe<String>;
}

export interface SessionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SessionWhereInput>;
  AND?: Maybe<SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput>;
  OR?: Maybe<SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput>;
  NOT?: Maybe<SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput>;
}

export interface DiscountRequestCreateInput {
  id?: Maybe<ID_Input>;
  discount: DiscountCreateOneWithoutDiscountRequestsInput;
  user: UserCreateOneWithoutDiscountRequestsInput;
  applied?: Maybe<Boolean>;
  approved?: Maybe<Boolean>;
  documentation?: Maybe<DiscountRequestCreatedocumentationInput>;
}

export interface OperatingPeriodSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OperatingPeriodWhereInput>;
  AND?: Maybe<
    | OperatingPeriodSubscriptionWhereInput[]
    | OperatingPeriodSubscriptionWhereInput
  >;
  OR?: Maybe<
    | OperatingPeriodSubscriptionWhereInput[]
    | OperatingPeriodSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | OperatingPeriodSubscriptionWhereInput[]
    | OperatingPeriodSubscriptionWhereInput
  >;
}

export interface DiscountRequestUpdateInput {
  discount?: Maybe<DiscountUpdateOneRequiredWithoutDiscountRequestsInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutDiscountRequestsInput>;
  applied?: Maybe<Boolean>;
  approved?: Maybe<Boolean>;
  documentation?: Maybe<DiscountRequestUpdatedocumentationInput>;
}

export interface EventSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EventWhereInput>;
  AND?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  OR?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  NOT?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
}

export interface DiscountRequestUpdateManyMutationInput {
  applied?: Maybe<Boolean>;
  approved?: Maybe<Boolean>;
  documentation?: Maybe<DiscountRequestUpdatedocumentationInput>;
}

export interface DeviceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  owner?: Maybe<UserWhereInput>;
  countryCode?: Maybe<String>;
  countryCode_not?: Maybe<String>;
  countryCode_in?: Maybe<String[] | String>;
  countryCode_not_in?: Maybe<String[] | String>;
  countryCode_lt?: Maybe<String>;
  countryCode_lte?: Maybe<String>;
  countryCode_gt?: Maybe<String>;
  countryCode_gte?: Maybe<String>;
  countryCode_contains?: Maybe<String>;
  countryCode_not_contains?: Maybe<String>;
  countryCode_starts_with?: Maybe<String>;
  countryCode_not_starts_with?: Maybe<String>;
  countryCode_ends_with?: Maybe<String>;
  countryCode_not_ends_with?: Maybe<String>;
  number?: Maybe<String>;
  number_not?: Maybe<String>;
  number_in?: Maybe<String[] | String>;
  number_not_in?: Maybe<String[] | String>;
  number_lt?: Maybe<String>;
  number_lte?: Maybe<String>;
  number_gt?: Maybe<String>;
  number_gte?: Maybe<String>;
  number_contains?: Maybe<String>;
  number_not_contains?: Maybe<String>;
  number_starts_with?: Maybe<String>;
  number_not_starts_with?: Maybe<String>;
  number_ends_with?: Maybe<String>;
  number_not_ends_with?: Maybe<String>;
  type?: Maybe<DeviceType>;
  type_not?: Maybe<DeviceType>;
  type_in?: Maybe<DeviceType[] | DeviceType>;
  type_not_in?: Maybe<DeviceType[] | DeviceType>;
  notificationsDevice?: Maybe<String>;
  notificationsDevice_not?: Maybe<String>;
  notificationsDevice_in?: Maybe<String[] | String>;
  notificationsDevice_not_in?: Maybe<String[] | String>;
  notificationsDevice_lt?: Maybe<String>;
  notificationsDevice_lte?: Maybe<String>;
  notificationsDevice_gt?: Maybe<String>;
  notificationsDevice_gte?: Maybe<String>;
  notificationsDevice_contains?: Maybe<String>;
  notificationsDevice_not_contains?: Maybe<String>;
  notificationsDevice_starts_with?: Maybe<String>;
  notificationsDevice_not_starts_with?: Maybe<String>;
  notificationsDevice_ends_with?: Maybe<String>;
  notificationsDevice_not_ends_with?: Maybe<String>;
  notificationsPermission?: Maybe<Boolean>;
  notificationsPermission_not?: Maybe<Boolean>;
  verified?: Maybe<Boolean>;
  verified_not?: Maybe<Boolean>;
  AND?: Maybe<DeviceWhereInput[] | DeviceWhereInput>;
  OR?: Maybe<DeviceWhereInput[] | DeviceWhereInput>;
  NOT?: Maybe<DeviceWhereInput[] | DeviceWhereInput>;
}

export interface EventCreateInput {
  id?: Maybe<ID_Input>;
  author: UserCreateOneWithoutEventsInput;
  title: String;
  subtitle?: Maybe<String>;
  organizer?: Maybe<String>;
  body: String;
  imageURL?: Maybe<String>;
  date: DateTimeInput;
  access?: Maybe<String>;
  accessPoint?: Maybe<String>;
  target: UserGroup;
  status?: Maybe<AppNodeStatus>;
  place: SpaceCreateOneWithoutEventsInput;
}

export interface SpaceUpsertWithWhereUniqueWithoutVenueInput {
  where: SpaceWhereUniqueInput;
  update: SpaceUpdateWithoutVenueDataInput;
  create: SpaceCreateWithoutVenueInput;
}

export interface EventUpdateInput {
  author?: Maybe<UserUpdateOneRequiredWithoutEventsInput>;
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  organizer?: Maybe<String>;
  body?: Maybe<String>;
  imageURL?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  access?: Maybe<String>;
  accessPoint?: Maybe<String>;
  target?: Maybe<UserGroup>;
  status?: Maybe<AppNodeStatus>;
  place?: Maybe<SpaceUpdateOneRequiredWithoutEventsInput>;
}

export interface SpaceCreateWithoutVenueInput {
  id?: Maybe<ID_Input>;
  name: String;
  events?: Maybe<EventCreateManyWithoutPlaceInput>;
  sessions?: Maybe<SessionCreateManyWithoutAtInput>;
}

export interface EventUpdateManyMutationInput {
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  organizer?: Maybe<String>;
  body?: Maybe<String>;
  imageURL?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  access?: Maybe<String>;
  accessPoint?: Maybe<String>;
  target?: Maybe<UserGroup>;
  status?: Maybe<AppNodeStatus>;
}

export interface OrderUpsertWithoutTransactionsInput {
  update: OrderUpdateWithoutTransactionsDataInput;
  create: OrderCreateWithoutTransactionsInput;
}

export interface ItemCreateInput {
  id?: Maybe<ID_Input>;
  order: OrderCreateOneWithoutItemsInput;
  product: ProductCreateOneWithoutOrdersInput;
  discount?: Maybe<DiscountCreateOneInput>;
  quantity: Int;
  orderPrice: Float;
}

export interface TransactionCreateInput {
  id?: Maybe<ID_Input>;
  type?: Maybe<TxType>;
  reference?: Maybe<String>;
  order?: Maybe<OrderCreateOneWithoutTransactionsInput>;
  amount: Int;
}

export interface ProductCreateOneWithoutOrdersInput {
  create?: Maybe<ProductCreateWithoutOrdersInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface SpaceCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  venue: VenueCreateOneWithoutSpacesInput;
  events?: Maybe<EventCreateManyWithoutPlaceInput>;
  sessions?: Maybe<SessionCreateManyWithoutAtInput>;
}

export interface ProductCreateWithoutOrdersInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  content?: Maybe<String>;
  unitPrice: Float;
  category: ProductCategoryCreateOneWithoutProductsInput;
  imageURLs?: Maybe<ProductCreateimageURLsInput>;
  discounts?: Maybe<DiscountCreateManyWithoutProductInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  firstname?: Maybe<String>;
  firstname_not?: Maybe<String>;
  firstname_in?: Maybe<String[] | String>;
  firstname_not_in?: Maybe<String[] | String>;
  firstname_lt?: Maybe<String>;
  firstname_lte?: Maybe<String>;
  firstname_gt?: Maybe<String>;
  firstname_gte?: Maybe<String>;
  firstname_contains?: Maybe<String>;
  firstname_not_contains?: Maybe<String>;
  firstname_starts_with?: Maybe<String>;
  firstname_not_starts_with?: Maybe<String>;
  firstname_ends_with?: Maybe<String>;
  firstname_not_ends_with?: Maybe<String>;
  lastname?: Maybe<String>;
  lastname_not?: Maybe<String>;
  lastname_in?: Maybe<String[] | String>;
  lastname_not_in?: Maybe<String[] | String>;
  lastname_lt?: Maybe<String>;
  lastname_lte?: Maybe<String>;
  lastname_gt?: Maybe<String>;
  lastname_gte?: Maybe<String>;
  lastname_contains?: Maybe<String>;
  lastname_not_contains?: Maybe<String>;
  lastname_starts_with?: Maybe<String>;
  lastname_not_starts_with?: Maybe<String>;
  lastname_ends_with?: Maybe<String>;
  lastname_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  emailVerified_not?: Maybe<Boolean>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  group?: Maybe<UserGroup>;
  group_not?: Maybe<UserGroup>;
  group_in?: Maybe<UserGroup[] | UserGroup>;
  group_not_in?: Maybe<UserGroup[] | UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  groupRequest_not?: Maybe<UserGroup>;
  groupRequest_in?: Maybe<UserGroup[] | UserGroup>;
  groupRequest_not_in?: Maybe<UserGroup[] | UserGroup>;
  isAdmin?: Maybe<Boolean>;
  isAdmin_not?: Maybe<Boolean>;
  roles_every?: Maybe<RoleWhereInput>;
  roles_some?: Maybe<RoleWhereInput>;
  roles_none?: Maybe<RoleWhereInput>;
  avatar?: Maybe<String>;
  avatar_not?: Maybe<String>;
  avatar_in?: Maybe<String[] | String>;
  avatar_not_in?: Maybe<String[] | String>;
  avatar_lt?: Maybe<String>;
  avatar_lte?: Maybe<String>;
  avatar_gt?: Maybe<String>;
  avatar_gte?: Maybe<String>;
  avatar_contains?: Maybe<String>;
  avatar_not_contains?: Maybe<String>;
  avatar_starts_with?: Maybe<String>;
  avatar_not_starts_with?: Maybe<String>;
  avatar_ends_with?: Maybe<String>;
  avatar_not_ends_with?: Maybe<String>;
  addresses_every?: Maybe<AddressWhereInput>;
  addresses_some?: Maybe<AddressWhereInput>;
  addresses_none?: Maybe<AddressWhereInput>;
  devices_every?: Maybe<DeviceWhereInput>;
  devices_some?: Maybe<DeviceWhereInput>;
  devices_none?: Maybe<DeviceWhereInput>;
  officialDocuments_every?: Maybe<OfficialDocumentWhereInput>;
  officialDocuments_some?: Maybe<OfficialDocumentWhereInput>;
  officialDocuments_none?: Maybe<OfficialDocumentWhereInput>;
  socialNetworkLinks_every?: Maybe<SocialLinkWhereInput>;
  socialNetworkLinks_some?: Maybe<SocialLinkWhereInput>;
  socialNetworkLinks_none?: Maybe<SocialLinkWhereInput>;
  department?: Maybe<DepartmentWhereInput>;
  newses_every?: Maybe<NewsWhereInput>;
  newses_some?: Maybe<NewsWhereInput>;
  newses_none?: Maybe<NewsWhereInput>;
  events_every?: Maybe<EventWhereInput>;
  events_some?: Maybe<EventWhereInput>;
  events_none?: Maybe<EventWhereInput>;
  lessonsManaged_every?: Maybe<LessonWhereInput>;
  lessonsManaged_some?: Maybe<LessonWhereInput>;
  lessonsManaged_none?: Maybe<LessonWhereInput>;
  availableLessons_every?: Maybe<LessonWhereInput>;
  availableLessons_some?: Maybe<LessonWhereInput>;
  availableLessons_none?: Maybe<LessonWhereInput>;
  teachedSessions_every?: Maybe<SessionWhereInput>;
  teachedSessions_some?: Maybe<SessionWhereInput>;
  teachedSessions_none?: Maybe<SessionWhereInput>;
  discountRequests_every?: Maybe<DiscountRequestWhereInput>;
  discountRequests_some?: Maybe<DiscountRequestWhereInput>;
  discountRequests_none?: Maybe<DiscountRequestWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface DiscountCreateManyWithoutProductInput {
  create?: Maybe<
    DiscountCreateWithoutProductInput[] | DiscountCreateWithoutProductInput
  >;
  connect?: Maybe<DiscountWhereUniqueInput[] | DiscountWhereUniqueInput>;
}

export interface UserUpsertWithoutSocialNetworkLinksInput {
  update: UserUpdateWithoutSocialNetworkLinksDataInput;
  create: UserCreateWithoutSocialNetworkLinksInput;
}

export interface DiscountCreateWithoutProductInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  code?: Maybe<String>;
  unitPrice: Float;
  discountRequests?: Maybe<DiscountRequestCreateManyWithoutDiscountInput>;
  requirements: String;
}

export interface SocialLinkCreateInput {
  id?: Maybe<ID_Input>;
  link: String;
  socialNetwork: SocialNetworkCreateOneWithoutUserLinksInput;
  owner: UserCreateOneWithoutSocialNetworkLinksInput;
}

export interface ItemUpdateInput {
  order?: Maybe<OrderUpdateOneRequiredWithoutItemsInput>;
  product?: Maybe<ProductUpdateOneRequiredWithoutOrdersInput>;
  discount?: Maybe<DiscountUpdateOneInput>;
  quantity?: Maybe<Int>;
  orderPrice?: Maybe<Float>;
}

export interface UserUpdateWithoutRolesDataInput {
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  email?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  password?: Maybe<String>;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressUpdateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceUpdateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentUpdateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkUpdateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  newses?: Maybe<NewsUpdateManyWithoutAuthorInput>;
  events?: Maybe<EventUpdateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonUpdateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonUpdateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionUpdateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestUpdateManyWithoutUserInput>;
}

export interface ProductUpdateOneRequiredWithoutOrdersInput {
  create?: Maybe<ProductCreateWithoutOrdersInput>;
  update?: Maybe<ProductUpdateWithoutOrdersDataInput>;
  upsert?: Maybe<ProductUpsertWithoutOrdersInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface RoleCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  users?: Maybe<UserCreateManyWithoutRolesInput>;
}

export interface ProductUpdateWithoutOrdersDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  content?: Maybe<String>;
  unitPrice?: Maybe<Float>;
  category?: Maybe<ProductCategoryUpdateOneRequiredWithoutProductsInput>;
  imageURLs?: Maybe<ProductUpdateimageURLsInput>;
  discounts?: Maybe<DiscountUpdateManyWithoutProductInput>;
}

export type SpaceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DiscountUpdateManyWithoutProductInput {
  create?: Maybe<
    DiscountCreateWithoutProductInput[] | DiscountCreateWithoutProductInput
  >;
  delete?: Maybe<DiscountWhereUniqueInput[] | DiscountWhereUniqueInput>;
  connect?: Maybe<DiscountWhereUniqueInput[] | DiscountWhereUniqueInput>;
  set?: Maybe<DiscountWhereUniqueInput[] | DiscountWhereUniqueInput>;
  disconnect?: Maybe<DiscountWhereUniqueInput[] | DiscountWhereUniqueInput>;
  update?: Maybe<
    | DiscountUpdateWithWhereUniqueWithoutProductInput[]
    | DiscountUpdateWithWhereUniqueWithoutProductInput
  >;
  upsert?: Maybe<
    | DiscountUpsertWithWhereUniqueWithoutProductInput[]
    | DiscountUpsertWithWhereUniqueWithoutProductInput
  >;
  deleteMany?: Maybe<DiscountScalarWhereInput[] | DiscountScalarWhereInput>;
  updateMany?: Maybe<
    | DiscountUpdateManyWithWhereNestedInput[]
    | DiscountUpdateManyWithWhereNestedInput
  >;
}

export type TransactionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DiscountUpdateWithWhereUniqueWithoutProductInput {
  where: DiscountWhereUniqueInput;
  data: DiscountUpdateWithoutProductDataInput;
}

export type VenueWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DiscountUpdateWithoutProductDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  code?: Maybe<String>;
  unitPrice?: Maybe<Float>;
  discountRequests?: Maybe<DiscountRequestUpdateManyWithoutDiscountInput>;
  requirements?: Maybe<String>;
}

export interface UserCreateWithoutAddressesInput {
  id?: Maybe<ID_Input>;
  firstname: String;
  lastname: String;
  email: String;
  emailVerified?: Maybe<Boolean>;
  password: String;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleCreateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  devices?: Maybe<DeviceCreateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentCreateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkCreateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  newses?: Maybe<NewsCreateManyWithoutAuthorInput>;
  events?: Maybe<EventCreateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonCreateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonCreateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionCreateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestCreateManyWithoutUserInput>;
}

export interface DiscountUpsertWithWhereUniqueWithoutProductInput {
  where: DiscountWhereUniqueInput;
  update: DiscountUpdateWithoutProductDataInput;
  create: DiscountCreateWithoutProductInput;
}

export interface SocialLinkCreateWithoutOwnerInput {
  id?: Maybe<ID_Input>;
  link: String;
  socialNetwork: SocialNetworkCreateOneWithoutUserLinksInput;
}

export interface DiscountScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  unitPrice?: Maybe<Float>;
  unitPrice_not?: Maybe<Float>;
  unitPrice_in?: Maybe<Float[] | Float>;
  unitPrice_not_in?: Maybe<Float[] | Float>;
  unitPrice_lt?: Maybe<Float>;
  unitPrice_lte?: Maybe<Float>;
  unitPrice_gt?: Maybe<Float>;
  unitPrice_gte?: Maybe<Float>;
  requirements?: Maybe<String>;
  requirements_not?: Maybe<String>;
  requirements_in?: Maybe<String[] | String>;
  requirements_not_in?: Maybe<String[] | String>;
  requirements_lt?: Maybe<String>;
  requirements_lte?: Maybe<String>;
  requirements_gt?: Maybe<String>;
  requirements_gte?: Maybe<String>;
  requirements_contains?: Maybe<String>;
  requirements_not_contains?: Maybe<String>;
  requirements_starts_with?: Maybe<String>;
  requirements_not_starts_with?: Maybe<String>;
  requirements_ends_with?: Maybe<String>;
  requirements_not_ends_with?: Maybe<String>;
  AND?: Maybe<DiscountScalarWhereInput[] | DiscountScalarWhereInput>;
  OR?: Maybe<DiscountScalarWhereInput[] | DiscountScalarWhereInput>;
  NOT?: Maybe<DiscountScalarWhereInput[] | DiscountScalarWhereInput>;
}

export interface EventCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  title: String;
  subtitle?: Maybe<String>;
  organizer?: Maybe<String>;
  body: String;
  imageURL?: Maybe<String>;
  date: DateTimeInput;
  access?: Maybe<String>;
  accessPoint?: Maybe<String>;
  target: UserGroup;
  status?: Maybe<AppNodeStatus>;
  place: SpaceCreateOneWithoutEventsInput;
}

export interface DiscountUpdateManyWithWhereNestedInput {
  where: DiscountScalarWhereInput;
  data: DiscountUpdateManyDataInput;
}

export interface LessonCreateWithoutSessionsInput {
  id?: Maybe<ID_Input>;
  name: String;
  subjects?: Maybe<SubjectCreateManyWithoutLessonInput>;
  period: OperatingPeriodCreateOneWithoutLessonsInput;
  manager: UserCreateOneWithoutLessonsManagedInput;
  availableTeachers?: Maybe<UserCreateManyWithoutAvailableLessonsInput>;
}

export interface DiscountUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  code?: Maybe<String>;
  unitPrice?: Maybe<Float>;
  requirements?: Maybe<String>;
}

export interface OperatingPeriodCreateWithoutLessonsInput {
  id?: Maybe<ID_Input>;
  yearStart: Int;
  yearEnd: Int;
}

export interface ProductUpsertWithoutOrdersInput {
  update: ProductUpdateWithoutOrdersDataInput;
  create: ProductCreateWithoutOrdersInput;
}

export interface SessionCreateWithoutLessonInput {
  id?: Maybe<ID_Input>;
  closedAt: DateTimeInput;
  by: UserCreateOneWithoutTeachedSessionsInput;
  at: SpaceCreateOneWithoutSessionsInput;
}

export interface ItemUpdateManyMutationInput {
  quantity?: Maybe<Int>;
  orderPrice?: Maybe<Float>;
}

export interface SessionCreateWithoutByInput {
  id?: Maybe<ID_Input>;
  lesson: LessonCreateOneWithoutSessionsInput;
  closedAt: DateTimeInput;
  at: SpaceCreateOneWithoutSessionsInput;
}

export interface LessonCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  subjects?: Maybe<SubjectCreateManyWithoutLessonInput>;
  period: OperatingPeriodCreateOneWithoutLessonsInput;
  sessions?: Maybe<SessionCreateManyWithoutLessonInput>;
  manager: UserCreateOneWithoutLessonsManagedInput;
  availableTeachers?: Maybe<UserCreateManyWithoutAvailableLessonsInput>;
}

export interface DiscountRequestCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  discount: DiscountCreateOneWithoutDiscountRequestsInput;
  applied?: Maybe<Boolean>;
  approved?: Maybe<Boolean>;
  documentation?: Maybe<DiscountRequestCreatedocumentationInput>;
}

export interface LessonUpdateInput {
  name?: Maybe<String>;
  subjects?: Maybe<SubjectUpdateManyWithoutLessonInput>;
  period?: Maybe<OperatingPeriodUpdateOneRequiredWithoutLessonsInput>;
  sessions?: Maybe<SessionUpdateManyWithoutLessonInput>;
  manager?: Maybe<UserUpdateOneRequiredWithoutLessonsManagedInput>;
  availableTeachers?: Maybe<UserUpdateManyWithoutAvailableLessonsInput>;
}

export interface ItemCreateManyWithoutProductInput {
  create?: Maybe<
    ItemCreateWithoutProductInput[] | ItemCreateWithoutProductInput
  >;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
}

export interface LessonUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface DiscountCreateOneInput {
  create?: Maybe<DiscountCreateInput>;
  connect?: Maybe<DiscountWhereUniqueInput>;
}

export interface NewsCreateInput {
  id?: Maybe<ID_Input>;
  author: UserCreateOneWithoutNewsesInput;
  title: String;
  subtitle?: Maybe<String>;
  body: String;
  imageURL?: Maybe<String>;
  expiration?: Maybe<DateTimeInput>;
  category?: Maybe<String>;
  featured?: Maybe<Boolean>;
  target: UserGroup;
  status?: Maybe<AppNodeStatus>;
}

export interface UserUpdateOneWithoutAddressesInput {
  create?: Maybe<UserCreateWithoutAddressesInput>;
  update?: Maybe<UserUpdateWithoutAddressesDataInput>;
  upsert?: Maybe<UserUpsertWithoutAddressesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateOneWithoutNewsesInput {
  create?: Maybe<UserCreateWithoutNewsesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface RoleUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface UserCreateWithoutNewsesInput {
  id?: Maybe<ID_Input>;
  firstname: String;
  lastname: String;
  email: String;
  emailVerified?: Maybe<Boolean>;
  password: String;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleCreateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressCreateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceCreateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentCreateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkCreateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  events?: Maybe<EventCreateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonCreateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonCreateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionCreateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestCreateManyWithoutUserInput>;
}

export interface OfficialDocumentUpdateManyWithoutOwnerInput {
  create?: Maybe<
    | OfficialDocumentCreateWithoutOwnerInput[]
    | OfficialDocumentCreateWithoutOwnerInput
  >;
  delete?: Maybe<
    OfficialDocumentWhereUniqueInput[] | OfficialDocumentWhereUniqueInput
  >;
  connect?: Maybe<
    OfficialDocumentWhereUniqueInput[] | OfficialDocumentWhereUniqueInput
  >;
  set?: Maybe<
    OfficialDocumentWhereUniqueInput[] | OfficialDocumentWhereUniqueInput
  >;
  disconnect?: Maybe<
    OfficialDocumentWhereUniqueInput[] | OfficialDocumentWhereUniqueInput
  >;
  update?: Maybe<
    | OfficialDocumentUpdateWithWhereUniqueWithoutOwnerInput[]
    | OfficialDocumentUpdateWithWhereUniqueWithoutOwnerInput
  >;
  upsert?: Maybe<
    | OfficialDocumentUpsertWithWhereUniqueWithoutOwnerInput[]
    | OfficialDocumentUpsertWithWhereUniqueWithoutOwnerInput
  >;
  deleteMany?: Maybe<
    OfficialDocumentScalarWhereInput[] | OfficialDocumentScalarWhereInput
  >;
  updateMany?: Maybe<
    | OfficialDocumentUpdateManyWithWhereNestedInput[]
    | OfficialDocumentUpdateManyWithWhereNestedInput
  >;
}

export interface NewsUpdateInput {
  author?: Maybe<UserUpdateOneRequiredWithoutNewsesInput>;
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  body?: Maybe<String>;
  imageURL?: Maybe<String>;
  expiration?: Maybe<DateTimeInput>;
  category?: Maybe<String>;
  featured?: Maybe<Boolean>;
  target?: Maybe<UserGroup>;
  status?: Maybe<AppNodeStatus>;
}

export interface ProgramWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  shortName?: Maybe<String>;
  shortName_not?: Maybe<String>;
  shortName_in?: Maybe<String[] | String>;
  shortName_not_in?: Maybe<String[] | String>;
  shortName_lt?: Maybe<String>;
  shortName_lte?: Maybe<String>;
  shortName_gt?: Maybe<String>;
  shortName_gte?: Maybe<String>;
  shortName_contains?: Maybe<String>;
  shortName_not_contains?: Maybe<String>;
  shortName_starts_with?: Maybe<String>;
  shortName_not_starts_with?: Maybe<String>;
  shortName_ends_with?: Maybe<String>;
  shortName_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  branches_every?: Maybe<BranchWhereInput>;
  branches_some?: Maybe<BranchWhereInput>;
  branches_none?: Maybe<BranchWhereInput>;
  AND?: Maybe<ProgramWhereInput[] | ProgramWhereInput>;
  OR?: Maybe<ProgramWhereInput[] | ProgramWhereInput>;
  NOT?: Maybe<ProgramWhereInput[] | ProgramWhereInput>;
}

export interface UserUpdateOneRequiredWithoutNewsesInput {
  create?: Maybe<UserCreateWithoutNewsesInput>;
  update?: Maybe<UserUpdateWithoutNewsesDataInput>;
  upsert?: Maybe<UserUpsertWithoutNewsesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface VenueWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  placeID?: Maybe<String>;
  placeID_not?: Maybe<String>;
  placeID_in?: Maybe<String[] | String>;
  placeID_not_in?: Maybe<String[] | String>;
  placeID_lt?: Maybe<String>;
  placeID_lte?: Maybe<String>;
  placeID_gt?: Maybe<String>;
  placeID_gte?: Maybe<String>;
  placeID_contains?: Maybe<String>;
  placeID_not_contains?: Maybe<String>;
  placeID_starts_with?: Maybe<String>;
  placeID_not_starts_with?: Maybe<String>;
  placeID_ends_with?: Maybe<String>;
  placeID_not_ends_with?: Maybe<String>;
  latitude?: Maybe<Float>;
  latitude_not?: Maybe<Float>;
  latitude_in?: Maybe<Float[] | Float>;
  latitude_not_in?: Maybe<Float[] | Float>;
  latitude_lt?: Maybe<Float>;
  latitude_lte?: Maybe<Float>;
  latitude_gt?: Maybe<Float>;
  latitude_gte?: Maybe<Float>;
  longitude?: Maybe<Float>;
  longitude_not?: Maybe<Float>;
  longitude_in?: Maybe<Float[] | Float>;
  longitude_not_in?: Maybe<Float[] | Float>;
  longitude_lt?: Maybe<Float>;
  longitude_lte?: Maybe<Float>;
  longitude_gt?: Maybe<Float>;
  longitude_gte?: Maybe<Float>;
  spaces_every?: Maybe<SpaceWhereInput>;
  spaces_some?: Maybe<SpaceWhereInput>;
  spaces_none?: Maybe<SpaceWhereInput>;
  AND?: Maybe<VenueWhereInput[] | VenueWhereInput>;
  OR?: Maybe<VenueWhereInput[] | VenueWhereInput>;
  NOT?: Maybe<VenueWhereInput[] | VenueWhereInput>;
}

export interface UserUpdateWithoutNewsesDataInput {
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  email?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  password?: Maybe<String>;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleUpdateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressUpdateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceUpdateManyWithoutOwnerInput>;
  officialDocuments?: Maybe<OfficialDocumentUpdateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkUpdateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  events?: Maybe<EventUpdateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonUpdateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonUpdateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionUpdateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestUpdateManyWithoutUserInput>;
}

export interface SocialLinkWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  socialNetwork?: Maybe<SocialNetworkWhereInput>;
  owner?: Maybe<UserWhereInput>;
  AND?: Maybe<SocialLinkWhereInput[] | SocialLinkWhereInput>;
  OR?: Maybe<SocialLinkWhereInput[] | SocialLinkWhereInput>;
  NOT?: Maybe<SocialLinkWhereInput[] | SocialLinkWhereInput>;
}

export interface UserUpsertWithoutNewsesInput {
  update: UserUpdateWithoutNewsesDataInput;
  create: UserCreateWithoutNewsesInput;
}

export interface SpaceUpdateWithWhereUniqueWithoutVenueInput {
  where: SpaceWhereUniqueInput;
  data: SpaceUpdateWithoutVenueDataInput;
}

export interface NewsUpdateManyMutationInput {
  title?: Maybe<String>;
  subtitle?: Maybe<String>;
  body?: Maybe<String>;
  imageURL?: Maybe<String>;
  expiration?: Maybe<DateTimeInput>;
  category?: Maybe<String>;
  featured?: Maybe<Boolean>;
  target?: Maybe<UserGroup>;
  status?: Maybe<AppNodeStatus>;
}

export interface TransactionUpdateInput {
  type?: Maybe<TxType>;
  reference?: Maybe<String>;
  order?: Maybe<OrderUpdateOneWithoutTransactionsInput>;
  amount?: Maybe<Int>;
}

export interface OfficialDocumentCreateInput {
  id?: Maybe<ID_Input>;
  number: String;
  type?: Maybe<OfficialDocumentType>;
  other?: Maybe<String>;
  expiration?: Maybe<DateTimeInput>;
  owner: UserCreateOneWithoutOfficialDocumentsInput;
}

export interface SocialLinkUpdateWithoutSocialNetworkDataInput {
  link?: Maybe<String>;
  owner?: Maybe<UserUpdateOneRequiredWithoutSocialNetworkLinksInput>;
}

export interface UserCreateOneWithoutOfficialDocumentsInput {
  create?: Maybe<UserCreateWithoutOfficialDocumentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface SocialLinkUpdateInput {
  link?: Maybe<String>;
  socialNetwork?: Maybe<SocialNetworkUpdateOneRequiredWithoutUserLinksInput>;
  owner?: Maybe<UserUpdateOneRequiredWithoutSocialNetworkLinksInput>;
}

export interface UserCreateWithoutOfficialDocumentsInput {
  id?: Maybe<ID_Input>;
  firstname: String;
  lastname: String;
  email: String;
  emailVerified?: Maybe<Boolean>;
  password: String;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleCreateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressCreateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceCreateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkCreateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentCreateOneWithoutMembersInput>;
  newses?: Maybe<NewsCreateManyWithoutAuthorInput>;
  events?: Maybe<EventCreateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonCreateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonCreateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionCreateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestCreateManyWithoutUserInput>;
}

export interface RoleUpdateInput {
  name?: Maybe<String>;
  users?: Maybe<UserUpdateManyWithoutRolesInput>;
}

export interface OfficialDocumentUpdateInput {
  number?: Maybe<String>;
  type?: Maybe<OfficialDocumentType>;
  other?: Maybe<String>;
  expiration?: Maybe<DateTimeInput>;
  owner?: Maybe<UserUpdateOneRequiredWithoutOfficialDocumentsInput>;
}

export type SubjectWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
  shortName?: Maybe<String>;
}>;

export interface UserUpdateOneRequiredWithoutOfficialDocumentsInput {
  create?: Maybe<UserCreateWithoutOfficialDocumentsInput>;
  update?: Maybe<UserUpdateWithoutOfficialDocumentsDataInput>;
  upsert?: Maybe<UserUpsertWithoutOfficialDocumentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ProductCreateWithoutCategoryInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  content?: Maybe<String>;
  unitPrice: Float;
  imageURLs?: Maybe<ProductCreateimageURLsInput>;
  discounts?: Maybe<DiscountCreateManyWithoutProductInput>;
  orders?: Maybe<ItemCreateManyWithoutProductInput>;
}

export interface UserUpdateWithoutOfficialDocumentsDataInput {
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  email?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  password?: Maybe<String>;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  roles?: Maybe<RoleUpdateManyWithoutUsersInput>;
  avatar?: Maybe<String>;
  addresses?: Maybe<AddressUpdateManyWithoutOwnerInput>;
  devices?: Maybe<DeviceUpdateManyWithoutOwnerInput>;
  socialNetworkLinks?: Maybe<SocialLinkUpdateManyWithoutOwnerInput>;
  metadata?: Maybe<Json>;
  department?: Maybe<DepartmentUpdateOneWithoutMembersInput>;
  newses?: Maybe<NewsUpdateManyWithoutAuthorInput>;
  events?: Maybe<EventUpdateManyWithoutAuthorInput>;
  lessonsManaged?: Maybe<LessonUpdateManyWithoutManagerInput>;
  availableLessons?: Maybe<LessonUpdateManyWithoutAvailableTeachersInput>;
  teachedSessions?: Maybe<SessionUpdateManyWithoutByInput>;
  discountRequests?: Maybe<DiscountRequestUpdateManyWithoutUserInput>;
}

export interface DepartmentCreateWithoutMembersInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface UserUpsertWithoutOfficialDocumentsInput {
  update: UserUpdateWithoutOfficialDocumentsDataInput;
  create: UserCreateWithoutOfficialDocumentsInput;
}

export interface BranchCreateWithoutSubjectsInput {
  id?: Maybe<ID_Input>;
  name: String;
  shortName: String;
  description?: Maybe<String>;
  program: ProgramCreateOneWithoutBranchesInput;
}

export interface OfficialDocumentUpdateManyMutationInput {
  number?: Maybe<String>;
  type?: Maybe<OfficialDocumentType>;
  other?: Maybe<String>;
  expiration?: Maybe<DateTimeInput>;
}

export interface LessonCreateWithoutManagerInput {
  id?: Maybe<ID_Input>;
  name: String;
  subjects?: Maybe<SubjectCreateManyWithoutLessonInput>;
  period: OperatingPeriodCreateOneWithoutLessonsInput;
  sessions?: Maybe<SessionCreateManyWithoutLessonInput>;
  availableTeachers?: Maybe<UserCreateManyWithoutAvailableLessonsInput>;
}

export interface OperatingPeriodCreateInput {
  id?: Maybe<ID_Input>;
  yearStart: Int;
  yearEnd: Int;
  lessons?: Maybe<LessonCreateManyWithoutPeriodInput>;
}

export interface ProductCreateWithoutDiscountsInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  content?: Maybe<String>;
  unitPrice: Float;
  category: ProductCategoryCreateOneWithoutProductsInput;
  imageURLs?: Maybe<ProductCreateimageURLsInput>;
  orders?: Maybe<ItemCreateManyWithoutProductInput>;
}

export interface LessonCreateManyWithoutPeriodInput {
  create?: Maybe<
    LessonCreateWithoutPeriodInput[] | LessonCreateWithoutPeriodInput
  >;
  connect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
}

export interface UserCreateOneWithoutDiscountRequestsInput {
  create?: Maybe<UserCreateWithoutDiscountRequestsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface LessonCreateWithoutPeriodInput {
  id?: Maybe<ID_Input>;
  name: String;
  subjects?: Maybe<SubjectCreateManyWithoutLessonInput>;
  sessions?: Maybe<SessionCreateManyWithoutLessonInput>;
  manager: UserCreateOneWithoutLessonsManagedInput;
  availableTeachers?: Maybe<UserCreateManyWithoutAvailableLessonsInput>;
}

export interface DeviceUpsertWithWhereUniqueWithoutOwnerInput {
  where: DeviceWhereUniqueInput;
  update: DeviceUpdateWithoutOwnerDataInput;
  create: DeviceCreateWithoutOwnerInput;
}

export interface OperatingPeriodUpdateInput {
  yearStart?: Maybe<Int>;
  yearEnd?: Maybe<Int>;
  lessons?: Maybe<LessonUpdateManyWithoutPeriodInput>;
}

export interface SocialNetworkSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SocialNetworkWhereInput>;
  AND?: Maybe<
    SocialNetworkSubscriptionWhereInput[] | SocialNetworkSubscriptionWhereInput
  >;
  OR?: Maybe<
    SocialNetworkSubscriptionWhereInput[] | SocialNetworkSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SocialNetworkSubscriptionWhereInput[] | SocialNetworkSubscriptionWhereInput
  >;
}

export interface LessonUpdateManyWithoutPeriodInput {
  create?: Maybe<
    LessonCreateWithoutPeriodInput[] | LessonCreateWithoutPeriodInput
  >;
  delete?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  connect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  set?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  disconnect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  update?: Maybe<
    | LessonUpdateWithWhereUniqueWithoutPeriodInput[]
    | LessonUpdateWithWhereUniqueWithoutPeriodInput
  >;
  upsert?: Maybe<
    | LessonUpsertWithWhereUniqueWithoutPeriodInput[]
    | LessonUpsertWithWhereUniqueWithoutPeriodInput
  >;
  deleteMany?: Maybe<LessonScalarWhereInput[] | LessonScalarWhereInput>;
  updateMany?: Maybe<
    | LessonUpdateManyWithWhereNestedInput[]
    | LessonUpdateManyWithWhereNestedInput
  >;
}

export interface SpaceUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface LessonUpdateWithWhereUniqueWithoutPeriodInput {
  where: LessonWhereUniqueInput;
  data: LessonUpdateWithoutPeriodDataInput;
}

export interface SubjectCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  shortName: String;
  description?: Maybe<String>;
  branch: BranchCreateOneWithoutSubjectsInput;
  lesson?: Maybe<LessonCreateOneWithoutSubjectsInput>;
}

export interface LessonUpdateWithoutPeriodDataInput {
  name?: Maybe<String>;
  subjects?: Maybe<SubjectUpdateManyWithoutLessonInput>;
  sessions?: Maybe<SessionUpdateManyWithoutLessonInput>;
  manager?: Maybe<UserUpdateOneRequiredWithoutLessonsManagedInput>;
  availableTeachers?: Maybe<UserUpdateManyWithoutAvailableLessonsInput>;
}

export interface SessionCreateInput {
  id?: Maybe<ID_Input>;
  lesson: LessonCreateOneWithoutSessionsInput;
  closedAt: DateTimeInput;
  by: UserCreateOneWithoutTeachedSessionsInput;
  at: SpaceCreateOneWithoutSessionsInput;
}

export interface LessonUpsertWithWhereUniqueWithoutPeriodInput {
  where: LessonWhereUniqueInput;
  update: LessonUpdateWithoutPeriodDataInput;
  create: LessonCreateWithoutPeriodInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface OperatingPeriodUpdateManyMutationInput {
  yearStart?: Maybe<Int>;
  yearEnd?: Maybe<Int>;
}

export interface VenueCreateWithoutSpacesInput {
  id?: Maybe<ID_Input>;
  name: String;
  address: String;
  placeID?: Maybe<String>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
}

export interface OrderCreateInput {
  id?: Maybe<ID_Input>;
  customer: UserCreateOneInput;
  items?: Maybe<ItemCreateManyWithoutOrderInput>;
  reference: String;
  metadata?: Maybe<Json>;
  paymentSettled?: Maybe<Boolean>;
  paymentDue?: Maybe<DateTimeInput>;
  transactions?: Maybe<TransactionCreateManyWithoutOrderInput>;
  vatRate?: Maybe<Int>;
  total: Float;
}

export interface EventCreateWithoutPlaceInput {
  id?: Maybe<ID_Input>;
  author: UserCreateOneWithoutEventsInput;
  title: String;
  subtitle?: Maybe<String>;
  organizer?: Maybe<String>;
  body: String;
  imageURL?: Maybe<String>;
  date: DateTimeInput;
  access?: Maybe<String>;
  accessPoint?: Maybe<String>;
  target: UserGroup;
  status?: Maybe<AppNodeStatus>;
}

export interface ItemCreateManyWithoutOrderInput {
  create?: Maybe<ItemCreateWithoutOrderInput[] | ItemCreateWithoutOrderInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
}

export interface RoleUpdateWithoutUsersDataInput {
  name?: Maybe<String>;
}

export interface ItemCreateWithoutOrderInput {
  id?: Maybe<ID_Input>;
  product: ProductCreateOneWithoutOrdersInput;
  discount?: Maybe<DiscountCreateOneInput>;
  quantity: Int;
  orderPrice: Float;
}

export interface LessonSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LessonWhereInput>;
  AND?: Maybe<LessonSubscriptionWhereInput[] | LessonSubscriptionWhereInput>;
  OR?: Maybe<LessonSubscriptionWhereInput[] | LessonSubscriptionWhereInput>;
  NOT?: Maybe<LessonSubscriptionWhereInput[] | LessonSubscriptionWhereInput>;
}

export interface OrderUpdateInput {
  customer?: Maybe<UserUpdateOneRequiredInput>;
  items?: Maybe<ItemUpdateManyWithoutOrderInput>;
  reference?: Maybe<String>;
  metadata?: Maybe<Json>;
  paymentSettled?: Maybe<Boolean>;
  paymentDue?: Maybe<DateTimeInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutOrderInput>;
  vatRate?: Maybe<Int>;
  total?: Maybe<Float>;
}

export type OrderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  reference?: Maybe<String>;
}>;

export interface ItemUpdateManyWithoutOrderInput {
  create?: Maybe<ItemCreateWithoutOrderInput[] | ItemCreateWithoutOrderInput>;
  delete?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  set?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  disconnect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  update?: Maybe<
    | ItemUpdateWithWhereUniqueWithoutOrderInput[]
    | ItemUpdateWithWhereUniqueWithoutOrderInput
  >;
  upsert?: Maybe<
    | ItemUpsertWithWhereUniqueWithoutOrderInput[]
    | ItemUpsertWithWhereUniqueWithoutOrderInput
  >;
  deleteMany?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  updateMany?: Maybe<
    ItemUpdateManyWithWhereNestedInput[] | ItemUpdateManyWithWhereNestedInput
  >;
}

export interface DeviceCreateWithoutOwnerInput {
  id?: Maybe<ID_Input>;
  countryCode?: Maybe<String>;
  number?: Maybe<String>;
  type?: Maybe<DeviceType>;
  notificationsDevice?: Maybe<String>;
  notificationsPermission?: Maybe<Boolean>;
  verified?: Maybe<Boolean>;
}

export interface OrderUpdateManyMutationInput {
  reference?: Maybe<String>;
  metadata?: Maybe<Json>;
  paymentSettled?: Maybe<Boolean>;
  paymentDue?: Maybe<DateTimeInput>;
  vatRate?: Maybe<Int>;
  total?: Maybe<Float>;
}

export interface ItemUpsertWithWhereUniqueWithoutOrderInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateWithoutOrderDataInput;
  create: ItemCreateWithoutOrderInput;
}

export interface ItemUpdateWithoutOrderDataInput {
  product?: Maybe<ProductUpdateOneRequiredWithoutOrdersInput>;
  discount?: Maybe<DiscountUpdateOneInput>;
  quantity?: Maybe<Int>;
  orderPrice?: Maybe<Float>;
}

export interface ItemUpdateWithWhereUniqueWithoutOrderInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateWithoutOrderDataInput;
}

export interface AddressCreateWithoutOwnerInput {
  id?: Maybe<ID_Input>;
  address1: String;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  region: String;
  country: String;
  code: String;
  primary?: Maybe<Boolean>;
}

export interface BranchUpdateManyWithWhereNestedInput {
  where: BranchScalarWhereInput;
  data: BranchUpdateManyDataInput;
}

export interface UserUpdateManyMutationInput {
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  email?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  password?: Maybe<String>;
  group?: Maybe<UserGroup>;
  groupRequest?: Maybe<UserGroup>;
  isAdmin?: Maybe<Boolean>;
  avatar?: Maybe<String>;
  metadata?: Maybe<Json>;
}

export interface OfficialDocumentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  number?: Maybe<String>;
  number_not?: Maybe<String>;
  number_in?: Maybe<String[] | String>;
  number_not_in?: Maybe<String[] | String>;
  number_lt?: Maybe<String>;
  number_lte?: Maybe<String>;
  number_gt?: Maybe<String>;
  number_gte?: Maybe<String>;
  number_contains?: Maybe<String>;
  number_not_contains?: Maybe<String>;
  number_starts_with?: Maybe<String>;
  number_not_starts_with?: Maybe<String>;
  number_ends_with?: Maybe<String>;
  number_not_ends_with?: Maybe<String>;
  type?: Maybe<OfficialDocumentType>;
  type_not?: Maybe<OfficialDocumentType>;
  type_in?: Maybe<OfficialDocumentType[] | OfficialDocumentType>;
  type_not_in?: Maybe<OfficialDocumentType[] | OfficialDocumentType>;
  other?: Maybe<String>;
  other_not?: Maybe<String>;
  other_in?: Maybe<String[] | String>;
  other_not_in?: Maybe<String[] | String>;
  other_lt?: Maybe<String>;
  other_lte?: Maybe<String>;
  other_gt?: Maybe<String>;
  other_gte?: Maybe<String>;
  other_contains?: Maybe<String>;
  other_not_contains?: Maybe<String>;
  other_starts_with?: Maybe<String>;
  other_not_starts_with?: Maybe<String>;
  other_ends_with?: Maybe<String>;
  other_not_ends_with?: Maybe<String>;
  expiration?: Maybe<DateTimeInput>;
  expiration_not?: Maybe<DateTimeInput>;
  expiration_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_lt?: Maybe<DateTimeInput>;
  expiration_lte?: Maybe<DateTimeInput>;
  expiration_gt?: Maybe<DateTimeInput>;
  expiration_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    OfficialDocumentScalarWhereInput[] | OfficialDocumentScalarWhereInput
  >;
  OR?: Maybe<
    OfficialDocumentScalarWhereInput[] | OfficialDocumentScalarWhereInput
  >;
  NOT?: Maybe<
    OfficialDocumentScalarWhereInput[] | OfficialDocumentScalarWhereInput
  >;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface VenuePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  address: String;
  placeID?: String;
  latitude?: Float;
  longitude?: Float;
}

export interface VenuePreviousValuesPromise
  extends Promise<VenuePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  placeID: () => Promise<String>;
  latitude: () => Promise<Float>;
  longitude: () => Promise<Float>;
}

export interface VenuePreviousValuesSubscription
  extends Promise<AsyncIterator<VenuePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  placeID: () => Promise<AsyncIterator<String>>;
  latitude: () => Promise<AsyncIterator<Float>>;
  longitude: () => Promise<AsyncIterator<Float>>;
}

export interface DepartmentConnection {
  pageInfo: PageInfo;
  edges: DepartmentEdge[];
}

export interface DepartmentConnectionPromise
  extends Promise<DepartmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DepartmentEdge>>() => T;
  aggregate: <T = AggregateDepartmentPromise>() => T;
}

export interface DepartmentConnectionSubscription
  extends Promise<AsyncIterator<DepartmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DepartmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDepartmentSubscription>() => T;
}

export interface TransactionSubscriptionPayload {
  mutation: MutationType;
  node: Transaction;
  updatedFields: String[];
  previousValues: TransactionPreviousValues;
}

export interface TransactionSubscriptionPayloadPromise
  extends Promise<TransactionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TransactionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TransactionPreviousValuesPromise>() => T;
}

export interface TransactionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TransactionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TransactionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TransactionPreviousValuesSubscription>() => T;
}

export interface AggregateBranch {
  count: Int;
}

export interface AggregateBranchPromise
  extends Promise<AggregateBranch>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBranchSubscription
  extends Promise<AsyncIterator<AggregateBranch>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BranchConnection {
  pageInfo: PageInfo;
  edges: BranchEdge[];
}

export interface BranchConnectionPromise
  extends Promise<BranchConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BranchEdge>>() => T;
  aggregate: <T = AggregateBranchPromise>() => T;
}

export interface BranchConnectionSubscription
  extends Promise<AsyncIterator<BranchConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BranchEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBranchSubscription>() => T;
}

export interface BranchEdge {
  node: Branch;
  cursor: String;
}

export interface BranchEdgePromise extends Promise<BranchEdge>, Fragmentable {
  node: <T = BranchPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BranchEdgeSubscription
  extends Promise<AsyncIterator<BranchEdge>>,
    Fragmentable {
  node: <T = BranchSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface VenueSubscriptionPayload {
  mutation: MutationType;
  node: Venue;
  updatedFields: String[];
  previousValues: VenuePreviousValues;
}

export interface VenueSubscriptionPayloadPromise
  extends Promise<VenueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VenuePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VenuePreviousValuesPromise>() => T;
}

export interface VenueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VenueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VenueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VenuePreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface VenueEdge {
  node: Venue;
  cursor: String;
}

export interface VenueEdgePromise extends Promise<VenueEdge>, Fragmentable {
  node: <T = VenuePromise>() => T;
  cursor: () => Promise<String>;
}

export interface VenueEdgeSubscription
  extends Promise<AsyncIterator<VenueEdge>>,
    Fragmentable {
  node: <T = VenueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAddress {
  count: Int;
}

export interface AggregateAddressPromise
  extends Promise<AggregateAddress>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAddressSubscription
  extends Promise<AsyncIterator<AggregateAddress>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Device {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  countryCode?: String;
  number?: String;
  type: DeviceType;
  notificationsDevice?: String;
  notificationsPermission?: Boolean;
  verified: Boolean;
}

export interface DevicePromise extends Promise<Device>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  owner: <T = UserPromise>() => T;
  countryCode: () => Promise<String>;
  number: () => Promise<String>;
  type: () => Promise<DeviceType>;
  notificationsDevice: () => Promise<String>;
  notificationsPermission: () => Promise<Boolean>;
  verified: () => Promise<Boolean>;
}

export interface DeviceSubscription
  extends Promise<AsyncIterator<Device>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  owner: <T = UserSubscription>() => T;
  countryCode: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<DeviceType>>;
  notificationsDevice: () => Promise<AsyncIterator<String>>;
  notificationsPermission: () => Promise<AsyncIterator<Boolean>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
}

export interface DeviceNullablePromise
  extends Promise<Device | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  owner: <T = UserPromise>() => T;
  countryCode: () => Promise<String>;
  number: () => Promise<String>;
  type: () => Promise<DeviceType>;
  notificationsDevice: () => Promise<String>;
  notificationsPermission: () => Promise<Boolean>;
  verified: () => Promise<Boolean>;
}

export interface AddressEdge {
  node: Address;
  cursor: String;
}

export interface AddressEdgePromise extends Promise<AddressEdge>, Fragmentable {
  node: <T = AddressPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AddressEdgeSubscription
  extends Promise<AsyncIterator<AddressEdge>>,
    Fragmentable {
  node: <T = AddressSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTransaction {
  count: Int;
}

export interface AggregateTransactionPromise
  extends Promise<AggregateTransaction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTransactionSubscription
  extends Promise<AsyncIterator<AggregateTransaction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AddressConnection {
  pageInfo: PageInfo;
  edges: AddressEdge[];
}

export interface AddressConnectionPromise
  extends Promise<AddressConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AddressEdge>>() => T;
  aggregate: <T = AggregateAddressPromise>() => T;
}

export interface AddressConnectionSubscription
  extends Promise<AsyncIterator<AddressConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AddressEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAddressSubscription>() => T;
}

export interface TransactionConnection {
  pageInfo: PageInfo;
  edges: TransactionEdge[];
}

export interface TransactionConnectionPromise
  extends Promise<TransactionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TransactionEdge>>() => T;
  aggregate: <T = AggregateTransactionPromise>() => T;
}

export interface TransactionConnectionSubscription
  extends Promise<AsyncIterator<TransactionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TransactionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTransactionSubscription>() => T;
}

export interface Address {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  address1: String;
  address2?: String;
  city?: String;
  region: String;
  country: String;
  code: String;
  primary: Boolean;
}

export interface AddressPromise extends Promise<Address>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  owner: <T = UserPromise>() => T;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  region: () => Promise<String>;
  country: () => Promise<String>;
  code: () => Promise<String>;
  primary: () => Promise<Boolean>;
}

export interface AddressSubscription
  extends Promise<AsyncIterator<Address>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  owner: <T = UserSubscription>() => T;
  address1: () => Promise<AsyncIterator<String>>;
  address2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  region: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  primary: () => Promise<AsyncIterator<Boolean>>;
}

export interface AddressNullablePromise
  extends Promise<Address | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  owner: <T = UserPromise>() => T;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  region: () => Promise<String>;
  country: () => Promise<String>;
  code: () => Promise<String>;
  primary: () => Promise<Boolean>;
}

export interface SubjectEdge {
  node: Subject;
  cursor: String;
}

export interface SubjectEdgePromise extends Promise<SubjectEdge>, Fragmentable {
  node: <T = SubjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubjectEdgeSubscription
  extends Promise<AsyncIterator<SubjectEdge>>,
    Fragmentable {
  node: <T = SubjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AddressSubscriptionPayload {
  mutation: MutationType;
  node: Address;
  updatedFields: String[];
  previousValues: AddressPreviousValues;
}

export interface AddressSubscriptionPayloadPromise
  extends Promise<AddressSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AddressPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AddressPreviousValuesPromise>() => T;
}

export interface AddressSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AddressSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AddressSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AddressPreviousValuesSubscription>() => T;
}

export interface AggregateSpace {
  count: Int;
}

export interface AggregateSpacePromise
  extends Promise<AggregateSpace>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSpaceSubscription
  extends Promise<AsyncIterator<AggregateSpace>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AddressPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  address1: String;
  address2?: String;
  city?: String;
  region: String;
  country: String;
  code: String;
  primary: Boolean;
}

export interface AddressPreviousValuesPromise
  extends Promise<AddressPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  region: () => Promise<String>;
  country: () => Promise<String>;
  code: () => Promise<String>;
  primary: () => Promise<Boolean>;
}

export interface AddressPreviousValuesSubscription
  extends Promise<AsyncIterator<AddressPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  address1: () => Promise<AsyncIterator<String>>;
  address2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  region: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  primary: () => Promise<AsyncIterator<Boolean>>;
}

export interface SpaceConnection {
  pageInfo: PageInfo;
  edges: SpaceEdge[];
}

export interface SpaceConnectionPromise
  extends Promise<SpaceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SpaceEdge>>() => T;
  aggregate: <T = AggregateSpacePromise>() => T;
}

export interface SpaceConnectionSubscription
  extends Promise<AsyncIterator<SpaceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SpaceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSpaceSubscription>() => T;
}

export interface Transaction {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  type: TxType;
  reference?: String;
  amount: Int;
}

export interface TransactionPromise extends Promise<Transaction>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<TxType>;
  reference: () => Promise<String>;
  order: <T = OrderPromise>() => T;
  amount: () => Promise<Int>;
}

export interface TransactionSubscription
  extends Promise<AsyncIterator<Transaction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<TxType>>;
  reference: () => Promise<AsyncIterator<String>>;
  order: <T = OrderSubscription>() => T;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface TransactionNullablePromise
  extends Promise<Transaction | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<TxType>;
  reference: () => Promise<String>;
  order: <T = OrderPromise>() => T;
  amount: () => Promise<Int>;
}

export interface SocialNetworkEdge {
  node: SocialNetwork;
  cursor: String;
}

export interface SocialNetworkEdgePromise
  extends Promise<SocialNetworkEdge>,
    Fragmentable {
  node: <T = SocialNetworkPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SocialNetworkEdgeSubscription
  extends Promise<AsyncIterator<SocialNetworkEdge>>,
    Fragmentable {
  node: <T = SocialNetworkSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BranchSubscriptionPayload {
  mutation: MutationType;
  node: Branch;
  updatedFields: String[];
  previousValues: BranchPreviousValues;
}

export interface BranchSubscriptionPayloadPromise
  extends Promise<BranchSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BranchPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BranchPreviousValuesPromise>() => T;
}

export interface BranchSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BranchSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BranchSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BranchPreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstname: String;
  lastname: String;
  email: String;
  emailVerified: Boolean;
  password: String;
  group: UserGroup;
  groupRequest?: UserGroup;
  isAdmin: Boolean;
  avatar?: String;
  metadata?: Json;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  email: () => Promise<String>;
  emailVerified: () => Promise<Boolean>;
  password: () => Promise<String>;
  group: () => Promise<UserGroup>;
  groupRequest: () => Promise<UserGroup>;
  isAdmin: () => Promise<Boolean>;
  roles: <T = FragmentableArray<Role>>(args?: {
    where?: RoleWhereInput;
    orderBy?: RoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  avatar: () => Promise<String>;
  addresses: <T = FragmentableArray<Address>>(args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  devices: <T = FragmentableArray<Device>>(args?: {
    where?: DeviceWhereInput;
    orderBy?: DeviceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  officialDocuments: <T = FragmentableArray<OfficialDocument>>(args?: {
    where?: OfficialDocumentWhereInput;
    orderBy?: OfficialDocumentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  socialNetworkLinks: <T = FragmentableArray<SocialLink>>(args?: {
    where?: SocialLinkWhereInput;
    orderBy?: SocialLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  metadata: () => Promise<Json>;
  department: <T = DepartmentPromise>() => T;
  newses: <T = FragmentableArray<News>>(args?: {
    where?: NewsWhereInput;
    orderBy?: NewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  events: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessonsManaged: <T = FragmentableArray<Lesson>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  availableLessons: <T = FragmentableArray<Lesson>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  teachedSessions: <T = FragmentableArray<Session>>(args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  discountRequests: <T = FragmentableArray<DiscountRequest>>(args?: {
    where?: DiscountRequestWhereInput;
    orderBy?: DiscountRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstname: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  emailVerified: () => Promise<AsyncIterator<Boolean>>;
  password: () => Promise<AsyncIterator<String>>;
  group: () => Promise<AsyncIterator<UserGroup>>;
  groupRequest: () => Promise<AsyncIterator<UserGroup>>;
  isAdmin: () => Promise<AsyncIterator<Boolean>>;
  roles: <T = Promise<AsyncIterator<RoleSubscription>>>(args?: {
    where?: RoleWhereInput;
    orderBy?: RoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  avatar: () => Promise<AsyncIterator<String>>;
  addresses: <T = Promise<AsyncIterator<AddressSubscription>>>(args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  devices: <T = Promise<AsyncIterator<DeviceSubscription>>>(args?: {
    where?: DeviceWhereInput;
    orderBy?: DeviceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  officialDocuments: <
    T = Promise<AsyncIterator<OfficialDocumentSubscription>>
  >(args?: {
    where?: OfficialDocumentWhereInput;
    orderBy?: OfficialDocumentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  socialNetworkLinks: <
    T = Promise<AsyncIterator<SocialLinkSubscription>>
  >(args?: {
    where?: SocialLinkWhereInput;
    orderBy?: SocialLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  metadata: () => Promise<AsyncIterator<Json>>;
  department: <T = DepartmentSubscription>() => T;
  newses: <T = Promise<AsyncIterator<NewsSubscription>>>(args?: {
    where?: NewsWhereInput;
    orderBy?: NewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  events: <T = Promise<AsyncIterator<EventSubscription>>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessonsManaged: <T = Promise<AsyncIterator<LessonSubscription>>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  availableLessons: <T = Promise<AsyncIterator<LessonSubscription>>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  teachedSessions: <T = Promise<AsyncIterator<SessionSubscription>>>(args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  discountRequests: <
    T = Promise<AsyncIterator<DiscountRequestSubscription>>
  >(args?: {
    where?: DiscountRequestWhereInput;
    orderBy?: DiscountRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  email: () => Promise<String>;
  emailVerified: () => Promise<Boolean>;
  password: () => Promise<String>;
  group: () => Promise<UserGroup>;
  groupRequest: () => Promise<UserGroup>;
  isAdmin: () => Promise<Boolean>;
  roles: <T = FragmentableArray<Role>>(args?: {
    where?: RoleWhereInput;
    orderBy?: RoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  avatar: () => Promise<String>;
  addresses: <T = FragmentableArray<Address>>(args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  devices: <T = FragmentableArray<Device>>(args?: {
    where?: DeviceWhereInput;
    orderBy?: DeviceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  officialDocuments: <T = FragmentableArray<OfficialDocument>>(args?: {
    where?: OfficialDocumentWhereInput;
    orderBy?: OfficialDocumentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  socialNetworkLinks: <T = FragmentableArray<SocialLink>>(args?: {
    where?: SocialLinkWhereInput;
    orderBy?: SocialLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  metadata: () => Promise<Json>;
  department: <T = DepartmentPromise>() => T;
  newses: <T = FragmentableArray<News>>(args?: {
    where?: NewsWhereInput;
    orderBy?: NewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  events: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lessonsManaged: <T = FragmentableArray<Lesson>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  availableLessons: <T = FragmentableArray<Lesson>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  teachedSessions: <T = FragmentableArray<Session>>(args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  discountRequests: <T = FragmentableArray<DiscountRequest>>(args?: {
    where?: DiscountRequestWhereInput;
    orderBy?: DiscountRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BranchPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  shortName: String;
  description?: String;
}

export interface BranchPreviousValuesPromise
  extends Promise<BranchPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  shortName: () => Promise<String>;
  description: () => Promise<String>;
}

export interface BranchPreviousValuesSubscription
  extends Promise<AsyncIterator<BranchPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  shortName: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface SocialLinkEdge {
  node: SocialLink;
  cursor: String;
}

export interface SocialLinkEdgePromise
  extends Promise<SocialLinkEdge>,
    Fragmentable {
  node: <T = SocialLinkPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SocialLinkEdgeSubscription
  extends Promise<AsyncIterator<SocialLinkEdge>>,
    Fragmentable {
  node: <T = SocialLinkSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Order {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  reference: String;
  metadata?: Json;
  paymentSettled: Boolean;
  paymentDue?: DateTimeOutput;
  vatRate?: Int;
  total: Float;
}

export interface OrderPromise extends Promise<Order>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  customer: <T = UserPromise>() => T;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reference: () => Promise<String>;
  metadata: () => Promise<Json>;
  paymentSettled: () => Promise<Boolean>;
  paymentDue: () => Promise<DateTimeOutput>;
  transactions: <T = FragmentableArray<Transaction>>(args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  vatRate: () => Promise<Int>;
  total: () => Promise<Float>;
}

export interface OrderSubscription
  extends Promise<AsyncIterator<Order>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  customer: <T = UserSubscription>() => T;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reference: () => Promise<AsyncIterator<String>>;
  metadata: () => Promise<AsyncIterator<Json>>;
  paymentSettled: () => Promise<AsyncIterator<Boolean>>;
  paymentDue: () => Promise<AsyncIterator<DateTimeOutput>>;
  transactions: <T = Promise<AsyncIterator<TransactionSubscription>>>(args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  vatRate: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<Float>>;
}

export interface OrderNullablePromise
  extends Promise<Order | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  customer: <T = UserPromise>() => T;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reference: () => Promise<String>;
  metadata: () => Promise<Json>;
  paymentSettled: () => Promise<Boolean>;
  paymentDue: () => Promise<DateTimeOutput>;
  transactions: <T = FragmentableArray<Transaction>>(args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  vatRate: () => Promise<Int>;
  total: () => Promise<Float>;
}

export interface AggregateSession {
  count: Int;
}

export interface AggregateSessionPromise
  extends Promise<AggregateSession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSessionSubscription
  extends Promise<AsyncIterator<AggregateSession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DepartmentSubscriptionPayload {
  mutation: MutationType;
  node: Department;
  updatedFields: String[];
  previousValues: DepartmentPreviousValues;
}

export interface DepartmentSubscriptionPayloadPromise
  extends Promise<DepartmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DepartmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DepartmentPreviousValuesPromise>() => T;
}

export interface DepartmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DepartmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DepartmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DepartmentPreviousValuesSubscription>() => T;
}

export interface SessionConnection {
  pageInfo: PageInfo;
  edges: SessionEdge[];
}

export interface SessionConnectionPromise
  extends Promise<SessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SessionEdge>>() => T;
  aggregate: <T = AggregateSessionPromise>() => T;
}

export interface SessionConnectionSubscription
  extends Promise<AsyncIterator<SessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSessionSubscription>() => T;
}

export interface DepartmentPreviousValues {
  id: ID_Output;
  name: String;
}

export interface DepartmentPreviousValuesPromise
  extends Promise<DepartmentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface DepartmentPreviousValuesSubscription
  extends Promise<AsyncIterator<DepartmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface RoleEdge {
  node: Role;
  cursor: String;
}

export interface RoleEdgePromise extends Promise<RoleEdge>, Fragmentable {
  node: <T = RolePromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoleEdgeSubscription
  extends Promise<AsyncIterator<RoleEdge>>,
    Fragmentable {
  node: <T = RoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Item {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  quantity: Int;
  orderPrice: Float;
}

export interface ItemPromise extends Promise<Item>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  order: <T = OrderPromise>() => T;
  product: <T = ProductPromise>() => T;
  discount: <T = DiscountPromise>() => T;
  quantity: () => Promise<Int>;
  orderPrice: () => Promise<Float>;
}

export interface ItemSubscription
  extends Promise<AsyncIterator<Item>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  order: <T = OrderSubscription>() => T;
  product: <T = ProductSubscription>() => T;
  discount: <T = DiscountSubscription>() => T;
  quantity: () => Promise<AsyncIterator<Int>>;
  orderPrice: () => Promise<AsyncIterator<Float>>;
}

export interface ItemNullablePromise
  extends Promise<Item | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  order: <T = OrderPromise>() => T;
  product: <T = ProductPromise>() => T;
  discount: <T = DiscountPromise>() => T;
  quantity: () => Promise<Int>;
  orderPrice: () => Promise<Float>;
}

export interface AggregateProgram {
  count: Int;
}

export interface AggregateProgramPromise
  extends Promise<AggregateProgram>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProgramSubscription
  extends Promise<AsyncIterator<AggregateProgram>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DeviceSubscriptionPayload {
  mutation: MutationType;
  node: Device;
  updatedFields: String[];
  previousValues: DevicePreviousValues;
}

export interface DeviceSubscriptionPayloadPromise
  extends Promise<DeviceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DevicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DevicePreviousValuesPromise>() => T;
}

export interface DeviceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DeviceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DeviceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DevicePreviousValuesSubscription>() => T;
}

export interface ProgramConnection {
  pageInfo: PageInfo;
  edges: ProgramEdge[];
}

export interface ProgramConnectionPromise
  extends Promise<ProgramConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProgramEdge>>() => T;
  aggregate: <T = AggregateProgramPromise>() => T;
}

export interface ProgramConnectionSubscription
  extends Promise<AsyncIterator<ProgramConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProgramEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProgramSubscription>() => T;
}

export interface DevicePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  countryCode?: String;
  number?: String;
  type: DeviceType;
  notificationsDevice?: String;
  notificationsPermission?: Boolean;
  verified: Boolean;
}

export interface DevicePreviousValuesPromise
  extends Promise<DevicePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  countryCode: () => Promise<String>;
  number: () => Promise<String>;
  type: () => Promise<DeviceType>;
  notificationsDevice: () => Promise<String>;
  notificationsPermission: () => Promise<Boolean>;
  verified: () => Promise<Boolean>;
}

export interface DevicePreviousValuesSubscription
  extends Promise<AsyncIterator<DevicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  countryCode: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<DeviceType>>;
  notificationsDevice: () => Promise<AsyncIterator<String>>;
  notificationsPermission: () => Promise<AsyncIterator<Boolean>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateProductCategory {
  count: Int;
}

export interface AggregateProductCategoryPromise
  extends Promise<AggregateProductCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductCategorySubscription
  extends Promise<AsyncIterator<AggregateProductCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductCategory {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface ProductCategoryPromise
  extends Promise<ProductCategory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductCategorySubscription
  extends Promise<AsyncIterator<ProductCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductCategoryNullablePromise
  extends Promise<ProductCategory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductCategoryConnection {
  pageInfo: PageInfo;
  edges: ProductCategoryEdge[];
}

export interface ProductCategoryConnectionPromise
  extends Promise<ProductCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductCategoryEdge>>() => T;
  aggregate: <T = AggregateProductCategoryPromise>() => T;
}

export interface ProductCategoryConnectionSubscription
  extends Promise<AsyncIterator<ProductCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductCategorySubscription>() => T;
}

export interface DiscountSubscriptionPayload {
  mutation: MutationType;
  node: Discount;
  updatedFields: String[];
  previousValues: DiscountPreviousValues;
}

export interface DiscountSubscriptionPayloadPromise
  extends Promise<DiscountSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DiscountPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DiscountPreviousValuesPromise>() => T;
}

export interface DiscountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DiscountSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DiscountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DiscountPreviousValuesSubscription>() => T;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DiscountPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  description: String;
  code?: String;
  unitPrice: Float;
  requirements: String;
}

export interface DiscountPreviousValuesPromise
  extends Promise<DiscountPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  code: () => Promise<String>;
  unitPrice: () => Promise<Float>;
  requirements: () => Promise<String>;
}

export interface DiscountPreviousValuesSubscription
  extends Promise<AsyncIterator<DiscountPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  unitPrice: () => Promise<AsyncIterator<Float>>;
  requirements: () => Promise<AsyncIterator<String>>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface Product {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  description: String;
  content?: String;
  unitPrice: Float;
  imageURLs: String[];
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  content: () => Promise<String>;
  unitPrice: () => Promise<Float>;
  category: <T = ProductCategoryPromise>() => T;
  imageURLs: () => Promise<String[]>;
  discounts: <T = FragmentableArray<Discount>>(args?: {
    where?: DiscountWhereInput;
    orderBy?: DiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orders: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  unitPrice: () => Promise<AsyncIterator<Float>>;
  category: <T = ProductCategorySubscription>() => T;
  imageURLs: () => Promise<AsyncIterator<String[]>>;
  discounts: <T = Promise<AsyncIterator<DiscountSubscription>>>(args?: {
    where?: DiscountWhereInput;
    orderBy?: DiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orders: <T = Promise<AsyncIterator<ItemSubscription>>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductNullablePromise
  extends Promise<Product | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  content: () => Promise<String>;
  unitPrice: () => Promise<Float>;
  category: <T = ProductCategoryPromise>() => T;
  imageURLs: () => Promise<String[]>;
  discounts: <T = FragmentableArray<Discount>>(args?: {
    where?: DiscountWhereInput;
    orderBy?: DiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orders: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface OrderEdge {
  node: Order;
  cursor: String;
}

export interface OrderEdgePromise extends Promise<OrderEdge>, Fragmentable {
  node: <T = OrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderEdgeSubscription
  extends Promise<AsyncIterator<OrderEdge>>,
    Fragmentable {
  node: <T = OrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DiscountRequestSubscriptionPayload {
  mutation: MutationType;
  node: DiscountRequest;
  updatedFields: String[];
  previousValues: DiscountRequestPreviousValues;
}

export interface DiscountRequestSubscriptionPayloadPromise
  extends Promise<DiscountRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DiscountRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DiscountRequestPreviousValuesPromise>() => T;
}

export interface DiscountRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DiscountRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DiscountRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DiscountRequestPreviousValuesSubscription>() => T;
}

export interface AggregateOperatingPeriod {
  count: Int;
}

export interface AggregateOperatingPeriodPromise
  extends Promise<AggregateOperatingPeriod>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOperatingPeriodSubscription
  extends Promise<AsyncIterator<AggregateOperatingPeriod>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DiscountRequestPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  applied: Boolean;
  approved: Boolean;
  documentation: String[];
}

export interface DiscountRequestPreviousValuesPromise
  extends Promise<DiscountRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  applied: () => Promise<Boolean>;
  approved: () => Promise<Boolean>;
  documentation: () => Promise<String[]>;
}

export interface DiscountRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<DiscountRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  applied: () => Promise<AsyncIterator<Boolean>>;
  approved: () => Promise<AsyncIterator<Boolean>>;
  documentation: () => Promise<AsyncIterator<String[]>>;
}

export interface OperatingPeriodConnection {
  pageInfo: PageInfo;
  edges: OperatingPeriodEdge[];
}

export interface OperatingPeriodConnectionPromise
  extends Promise<OperatingPeriodConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OperatingPeriodEdge>>() => T;
  aggregate: <T = AggregateOperatingPeriodPromise>() => T;
}

export interface OperatingPeriodConnectionSubscription
  extends Promise<AsyncIterator<OperatingPeriodConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OperatingPeriodEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOperatingPeriodSubscription>() => T;
}

export interface Discount {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  description: String;
  code?: String;
  unitPrice: Float;
  requirements: String;
}

export interface DiscountPromise extends Promise<Discount>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  product: <T = ProductPromise>() => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  code: () => Promise<String>;
  unitPrice: () => Promise<Float>;
  discountRequests: <T = FragmentableArray<DiscountRequest>>(args?: {
    where?: DiscountRequestWhereInput;
    orderBy?: DiscountRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  requirements: () => Promise<String>;
}

export interface DiscountSubscription
  extends Promise<AsyncIterator<Discount>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  product: <T = ProductSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  unitPrice: () => Promise<AsyncIterator<Float>>;
  discountRequests: <
    T = Promise<AsyncIterator<DiscountRequestSubscription>>
  >(args?: {
    where?: DiscountRequestWhereInput;
    orderBy?: DiscountRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  requirements: () => Promise<AsyncIterator<String>>;
}

export interface DiscountNullablePromise
  extends Promise<Discount | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  product: <T = ProductPromise>() => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  code: () => Promise<String>;
  unitPrice: () => Promise<Float>;
  discountRequests: <T = FragmentableArray<DiscountRequest>>(args?: {
    where?: DiscountRequestWhereInput;
    orderBy?: DiscountRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  requirements: () => Promise<String>;
}

export interface OfficialDocumentEdge {
  node: OfficialDocument;
  cursor: String;
}

export interface OfficialDocumentEdgePromise
  extends Promise<OfficialDocumentEdge>,
    Fragmentable {
  node: <T = OfficialDocumentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OfficialDocumentEdgeSubscription
  extends Promise<AsyncIterator<OfficialDocumentEdge>>,
    Fragmentable {
  node: <T = OfficialDocumentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EventSubscriptionPayload {
  mutation: MutationType;
  node: Event;
  updatedFields: String[];
  previousValues: EventPreviousValues;
}

export interface EventSubscriptionPayloadPromise
  extends Promise<EventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPreviousValuesPromise>() => T;
}

export interface EventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPreviousValuesSubscription>() => T;
}

export interface AggregateNews {
  count: Int;
}

export interface AggregateNewsPromise
  extends Promise<AggregateNews>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNewsSubscription
  extends Promise<AsyncIterator<AggregateNews>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EventPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  subtitle?: String;
  organizer?: String;
  body: String;
  imageURL?: String;
  date: DateTimeOutput;
  access?: String;
  accessPoint?: String;
  target: UserGroup;
  status: AppNodeStatus;
}

export interface EventPreviousValuesPromise
  extends Promise<EventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  subtitle: () => Promise<String>;
  organizer: () => Promise<String>;
  body: () => Promise<String>;
  imageURL: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  access: () => Promise<String>;
  accessPoint: () => Promise<String>;
  target: () => Promise<UserGroup>;
  status: () => Promise<AppNodeStatus>;
}

export interface EventPreviousValuesSubscription
  extends Promise<AsyncIterator<EventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  subtitle: () => Promise<AsyncIterator<String>>;
  organizer: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  imageURL: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  access: () => Promise<AsyncIterator<String>>;
  accessPoint: () => Promise<AsyncIterator<String>>;
  target: () => Promise<AsyncIterator<UserGroup>>;
  status: () => Promise<AsyncIterator<AppNodeStatus>>;
}

export interface NewsConnection {
  pageInfo: PageInfo;
  edges: NewsEdge[];
}

export interface NewsConnectionPromise
  extends Promise<NewsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NewsEdge>>() => T;
  aggregate: <T = AggregateNewsPromise>() => T;
}

export interface NewsConnectionSubscription
  extends Promise<AsyncIterator<NewsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NewsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNewsSubscription>() => T;
}

export interface DiscountRequest {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  applied: Boolean;
  approved: Boolean;
  documentation: String[];
}

export interface DiscountRequestPromise
  extends Promise<DiscountRequest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  discount: <T = DiscountPromise>() => T;
  user: <T = UserPromise>() => T;
  applied: () => Promise<Boolean>;
  approved: () => Promise<Boolean>;
  documentation: () => Promise<String[]>;
}

export interface DiscountRequestSubscription
  extends Promise<AsyncIterator<DiscountRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  discount: <T = DiscountSubscription>() => T;
  user: <T = UserSubscription>() => T;
  applied: () => Promise<AsyncIterator<Boolean>>;
  approved: () => Promise<AsyncIterator<Boolean>>;
  documentation: () => Promise<AsyncIterator<String[]>>;
}

export interface DiscountRequestNullablePromise
  extends Promise<DiscountRequest | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  discount: <T = DiscountPromise>() => T;
  user: <T = UserPromise>() => T;
  applied: () => Promise<Boolean>;
  approved: () => Promise<Boolean>;
  documentation: () => Promise<String[]>;
}

export interface LessonEdge {
  node: Lesson;
  cursor: String;
}

export interface LessonEdgePromise extends Promise<LessonEdge>, Fragmentable {
  node: <T = LessonPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LessonEdgeSubscription
  extends Promise<AsyncIterator<LessonEdge>>,
    Fragmentable {
  node: <T = LessonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ItemSubscriptionPayload {
  mutation: MutationType;
  node: Item;
  updatedFields: String[];
  previousValues: ItemPreviousValues;
}

export interface ItemSubscriptionPayloadPromise
  extends Promise<ItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemPreviousValuesPromise>() => T;
}

export interface ItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemPreviousValuesSubscription>() => T;
}

export interface AggregateItem {
  count: Int;
}

export interface AggregateItemPromise
  extends Promise<AggregateItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemSubscription
  extends Promise<AsyncIterator<AggregateItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ItemPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  quantity: Int;
  orderPrice: Float;
}

export interface ItemPreviousValuesPromise
  extends Promise<ItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  quantity: () => Promise<Int>;
  orderPrice: () => Promise<Float>;
}

export interface ItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  orderPrice: () => Promise<AsyncIterator<Float>>;
}

export interface ItemConnection {
  pageInfo: PageInfo;
  edges: ItemEdge[];
}

export interface ItemConnectionPromise
  extends Promise<ItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ItemEdge>>() => T;
  aggregate: <T = AggregateItemPromise>() => T;
}

export interface ItemConnectionSubscription
  extends Promise<AsyncIterator<ItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemSubscription>() => T;
}

export interface OperatingPeriod {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  yearStart: Int;
  yearEnd: Int;
}

export interface OperatingPeriodPromise
  extends Promise<OperatingPeriod>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  yearStart: () => Promise<Int>;
  yearEnd: () => Promise<Int>;
  lessons: <T = FragmentableArray<Lesson>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface OperatingPeriodSubscription
  extends Promise<AsyncIterator<OperatingPeriod>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  yearStart: () => Promise<AsyncIterator<Int>>;
  yearEnd: () => Promise<AsyncIterator<Int>>;
  lessons: <T = Promise<AsyncIterator<LessonSubscription>>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface OperatingPeriodNullablePromise
  extends Promise<OperatingPeriod | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  yearStart: () => Promise<Int>;
  yearEnd: () => Promise<Int>;
  lessons: <T = FragmentableArray<Lesson>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EventEdge {
  node: Event;
  cursor: String;
}

export interface EventEdgePromise extends Promise<EventEdge>, Fragmentable {
  node: <T = EventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventEdgeSubscription
  extends Promise<AsyncIterator<EventEdge>>,
    Fragmentable {
  node: <T = EventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LessonSubscriptionPayload {
  mutation: MutationType;
  node: Lesson;
  updatedFields: String[];
  previousValues: LessonPreviousValues;
}

export interface LessonSubscriptionPayloadPromise
  extends Promise<LessonSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LessonPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LessonPreviousValuesPromise>() => T;
}

export interface LessonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LessonSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LessonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LessonPreviousValuesSubscription>() => T;
}

export interface AggregateDiscountRequest {
  count: Int;
}

export interface AggregateDiscountRequestPromise
  extends Promise<AggregateDiscountRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDiscountRequestSubscription
  extends Promise<AsyncIterator<AggregateDiscountRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LessonPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface LessonPreviousValuesPromise
  extends Promise<LessonPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface LessonPreviousValuesSubscription
  extends Promise<AsyncIterator<LessonPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface DiscountRequestConnection {
  pageInfo: PageInfo;
  edges: DiscountRequestEdge[];
}

export interface DiscountRequestConnectionPromise
  extends Promise<DiscountRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DiscountRequestEdge>>() => T;
  aggregate: <T = AggregateDiscountRequestPromise>() => T;
}

export interface DiscountRequestConnectionSubscription
  extends Promise<AsyncIterator<DiscountRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DiscountRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDiscountRequestSubscription>() => T;
}

export interface Program {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  shortName: String;
  description?: String;
}

export interface ProgramPromise extends Promise<Program>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  shortName: () => Promise<String>;
  description: () => Promise<String>;
  branches: <T = FragmentableArray<Branch>>(args?: {
    where?: BranchWhereInput;
    orderBy?: BranchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProgramSubscription
  extends Promise<AsyncIterator<Program>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  shortName: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  branches: <T = Promise<AsyncIterator<BranchSubscription>>>(args?: {
    where?: BranchWhereInput;
    orderBy?: BranchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProgramNullablePromise
  extends Promise<Program | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  shortName: () => Promise<String>;
  description: () => Promise<String>;
  branches: <T = FragmentableArray<Branch>>(args?: {
    where?: BranchWhereInput;
    orderBy?: BranchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DiscountEdge {
  node: Discount;
  cursor: String;
}

export interface DiscountEdgePromise
  extends Promise<DiscountEdge>,
    Fragmentable {
  node: <T = DiscountPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DiscountEdgeSubscription
  extends Promise<AsyncIterator<DiscountEdge>>,
    Fragmentable {
  node: <T = DiscountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface NewsSubscriptionPayload {
  mutation: MutationType;
  node: News;
  updatedFields: String[];
  previousValues: NewsPreviousValues;
}

export interface NewsSubscriptionPayloadPromise
  extends Promise<NewsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NewsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NewsPreviousValuesPromise>() => T;
}

export interface NewsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NewsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NewsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NewsPreviousValuesSubscription>() => T;
}

export interface AggregateDevice {
  count: Int;
}

export interface AggregateDevicePromise
  extends Promise<AggregateDevice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDeviceSubscription
  extends Promise<AsyncIterator<AggregateDevice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NewsPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  subtitle?: String;
  body: String;
  imageURL?: String;
  expiration?: DateTimeOutput;
  category?: String;
  featured?: Boolean;
  target: UserGroup;
  status: AppNodeStatus;
}

export interface NewsPreviousValuesPromise
  extends Promise<NewsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  subtitle: () => Promise<String>;
  body: () => Promise<String>;
  imageURL: () => Promise<String>;
  expiration: () => Promise<DateTimeOutput>;
  category: () => Promise<String>;
  featured: () => Promise<Boolean>;
  target: () => Promise<UserGroup>;
  status: () => Promise<AppNodeStatus>;
}

export interface NewsPreviousValuesSubscription
  extends Promise<AsyncIterator<NewsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  subtitle: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  imageURL: () => Promise<AsyncIterator<String>>;
  expiration: () => Promise<AsyncIterator<DateTimeOutput>>;
  category: () => Promise<AsyncIterator<String>>;
  featured: () => Promise<AsyncIterator<Boolean>>;
  target: () => Promise<AsyncIterator<UserGroup>>;
  status: () => Promise<AsyncIterator<AppNodeStatus>>;
}

export interface DeviceConnection {
  pageInfo: PageInfo;
  edges: DeviceEdge[];
}

export interface DeviceConnectionPromise
  extends Promise<DeviceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DeviceEdge>>() => T;
  aggregate: <T = AggregateDevicePromise>() => T;
}

export interface DeviceConnectionSubscription
  extends Promise<AsyncIterator<DeviceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DeviceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDeviceSubscription>() => T;
}

export interface Branch {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  shortName: String;
  description?: String;
}

export interface BranchPromise extends Promise<Branch>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  shortName: () => Promise<String>;
  description: () => Promise<String>;
  program: <T = ProgramPromise>() => T;
  subjects: <T = FragmentableArray<Subject>>(args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BranchSubscription
  extends Promise<AsyncIterator<Branch>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  shortName: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  program: <T = ProgramSubscription>() => T;
  subjects: <T = Promise<AsyncIterator<SubjectSubscription>>>(args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BranchNullablePromise
  extends Promise<Branch | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  shortName: () => Promise<String>;
  description: () => Promise<String>;
  program: <T = ProgramPromise>() => T;
  subjects: <T = FragmentableArray<Subject>>(args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DepartmentEdge {
  node: Department;
  cursor: String;
}

export interface DepartmentEdgePromise
  extends Promise<DepartmentEdge>,
    Fragmentable {
  node: <T = DepartmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DepartmentEdgeSubscription
  extends Promise<AsyncIterator<DepartmentEdge>>,
    Fragmentable {
  node: <T = DepartmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OfficialDocumentSubscriptionPayload {
  mutation: MutationType;
  node: OfficialDocument;
  updatedFields: String[];
  previousValues: OfficialDocumentPreviousValues;
}

export interface OfficialDocumentSubscriptionPayloadPromise
  extends Promise<OfficialDocumentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OfficialDocumentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OfficialDocumentPreviousValuesPromise>() => T;
}

export interface OfficialDocumentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OfficialDocumentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OfficialDocumentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OfficialDocumentPreviousValuesSubscription>() => T;
}

export interface AggregateVenue {
  count: Int;
}

export interface AggregateVenuePromise
  extends Promise<AggregateVenue>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVenueSubscription
  extends Promise<AsyncIterator<AggregateVenue>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OfficialDocumentPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  number: String;
  type?: OfficialDocumentType;
  other?: String;
  expiration?: DateTimeOutput;
}

export interface OfficialDocumentPreviousValuesPromise
  extends Promise<OfficialDocumentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  number: () => Promise<String>;
  type: () => Promise<OfficialDocumentType>;
  other: () => Promise<String>;
  expiration: () => Promise<DateTimeOutput>;
}

export interface OfficialDocumentPreviousValuesSubscription
  extends Promise<AsyncIterator<OfficialDocumentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  number: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<OfficialDocumentType>>;
  other: () => Promise<AsyncIterator<String>>;
  expiration: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Subject {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  shortName: String;
  description?: String;
}

export interface SubjectPromise extends Promise<Subject>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  shortName: () => Promise<String>;
  description: () => Promise<String>;
  branch: <T = BranchPromise>() => T;
  lesson: <T = LessonPromise>() => T;
}

export interface SubjectSubscription
  extends Promise<AsyncIterator<Subject>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  shortName: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  branch: <T = BranchSubscription>() => T;
  lesson: <T = LessonSubscription>() => T;
}

export interface SubjectNullablePromise
  extends Promise<Subject | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  shortName: () => Promise<String>;
  description: () => Promise<String>;
  branch: <T = BranchPromise>() => T;
  lesson: <T = LessonPromise>() => T;
}

export interface TransactionEdge {
  node: Transaction;
  cursor: String;
}

export interface TransactionEdgePromise
  extends Promise<TransactionEdge>,
    Fragmentable {
  node: <T = TransactionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TransactionEdgeSubscription
  extends Promise<AsyncIterator<TransactionEdge>>,
    Fragmentable {
  node: <T = TransactionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OperatingPeriodSubscriptionPayload {
  mutation: MutationType;
  node: OperatingPeriod;
  updatedFields: String[];
  previousValues: OperatingPeriodPreviousValues;
}

export interface OperatingPeriodSubscriptionPayloadPromise
  extends Promise<OperatingPeriodSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OperatingPeriodPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OperatingPeriodPreviousValuesPromise>() => T;
}

export interface OperatingPeriodSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OperatingPeriodSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OperatingPeriodSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OperatingPeriodPreviousValuesSubscription>() => T;
}

export interface SubjectConnection {
  pageInfo: PageInfo;
  edges: SubjectEdge[];
}

export interface SubjectConnectionPromise
  extends Promise<SubjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubjectEdge>>() => T;
  aggregate: <T = AggregateSubjectPromise>() => T;
}

export interface SubjectConnectionSubscription
  extends Promise<AsyncIterator<SubjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubjectSubscription>() => T;
}

export interface OperatingPeriodPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  yearStart: Int;
  yearEnd: Int;
}

export interface OperatingPeriodPreviousValuesPromise
  extends Promise<OperatingPeriodPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  yearStart: () => Promise<Int>;
  yearEnd: () => Promise<Int>;
}

export interface OperatingPeriodPreviousValuesSubscription
  extends Promise<AsyncIterator<OperatingPeriodPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  yearStart: () => Promise<AsyncIterator<Int>>;
  yearEnd: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateSocialNetwork {
  count: Int;
}

export interface AggregateSocialNetworkPromise
  extends Promise<AggregateSocialNetwork>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSocialNetworkSubscription
  extends Promise<AsyncIterator<AggregateSocialNetwork>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Lesson {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface LessonPromise extends Promise<Lesson>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  subjects: <T = FragmentableArray<Subject>>(args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  period: <T = OperatingPeriodPromise>() => T;
  sessions: <T = FragmentableArray<Session>>(args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  manager: <T = UserPromise>() => T;
  availableTeachers: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface LessonSubscription
  extends Promise<AsyncIterator<Lesson>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  subjects: <T = Promise<AsyncIterator<SubjectSubscription>>>(args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  period: <T = OperatingPeriodSubscription>() => T;
  sessions: <T = Promise<AsyncIterator<SessionSubscription>>>(args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  manager: <T = UserSubscription>() => T;
  availableTeachers: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface LessonNullablePromise
  extends Promise<Lesson | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  subjects: <T = FragmentableArray<Subject>>(args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  period: <T = OperatingPeriodPromise>() => T;
  sessions: <T = FragmentableArray<Session>>(args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  manager: <T = UserPromise>() => T;
  availableTeachers: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateSocialLink {
  count: Int;
}

export interface AggregateSocialLinkPromise
  extends Promise<AggregateSocialLink>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSocialLinkSubscription
  extends Promise<AsyncIterator<AggregateSocialLink>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderSubscriptionPayload {
  mutation: MutationType;
  node: Order;
  updatedFields: String[];
  previousValues: OrderPreviousValues;
}

export interface OrderSubscriptionPayloadPromise
  extends Promise<OrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPreviousValuesPromise>() => T;
}

export interface OrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPreviousValuesSubscription>() => T;
}

export interface SessionEdge {
  node: Session;
  cursor: String;
}

export interface SessionEdgePromise extends Promise<SessionEdge>, Fragmentable {
  node: <T = SessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SessionEdgeSubscription
  extends Promise<AsyncIterator<SessionEdge>>,
    Fragmentable {
  node: <T = SessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OrderPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  reference: String;
  metadata?: Json;
  paymentSettled: Boolean;
  paymentDue?: DateTimeOutput;
  vatRate?: Int;
  total: Float;
}

export interface OrderPreviousValuesPromise
  extends Promise<OrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  reference: () => Promise<String>;
  metadata: () => Promise<Json>;
  paymentSettled: () => Promise<Boolean>;
  paymentDue: () => Promise<DateTimeOutput>;
  vatRate: () => Promise<Int>;
  total: () => Promise<Float>;
}

export interface OrderPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  reference: () => Promise<AsyncIterator<String>>;
  metadata: () => Promise<AsyncIterator<Json>>;
  paymentSettled: () => Promise<AsyncIterator<Boolean>>;
  paymentDue: () => Promise<AsyncIterator<DateTimeOutput>>;
  vatRate: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<Float>>;
}

export interface RoleConnection {
  pageInfo: PageInfo;
  edges: RoleEdge[];
}

export interface RoleConnectionPromise
  extends Promise<RoleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoleEdge>>() => T;
  aggregate: <T = AggregateRolePromise>() => T;
}

export interface RoleConnectionSubscription
  extends Promise<AsyncIterator<RoleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RoleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRoleSubscription>() => T;
}

export interface Session {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  closedAt: DateTimeOutput;
}

export interface SessionPromise extends Promise<Session>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  lesson: <T = LessonPromise>() => T;
  closedAt: () => Promise<DateTimeOutput>;
  by: <T = UserPromise>() => T;
  at: <T = SpacePromise>() => T;
}

export interface SessionSubscription
  extends Promise<AsyncIterator<Session>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  lesson: <T = LessonSubscription>() => T;
  closedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  by: <T = UserSubscription>() => T;
  at: <T = SpaceSubscription>() => T;
}

export interface SessionNullablePromise
  extends Promise<Session | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  lesson: <T = LessonPromise>() => T;
  closedAt: () => Promise<DateTimeOutput>;
  by: <T = UserPromise>() => T;
  at: <T = SpacePromise>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstname: String;
  lastname: String;
  email: String;
  emailVerified: Boolean;
  password: String;
  group: UserGroup;
  groupRequest?: UserGroup;
  isAdmin: Boolean;
  avatar?: String;
  metadata?: Json;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  email: () => Promise<String>;
  emailVerified: () => Promise<Boolean>;
  password: () => Promise<String>;
  group: () => Promise<UserGroup>;
  groupRequest: () => Promise<UserGroup>;
  isAdmin: () => Promise<Boolean>;
  avatar: () => Promise<String>;
  metadata: () => Promise<Json>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstname: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  emailVerified: () => Promise<AsyncIterator<Boolean>>;
  password: () => Promise<AsyncIterator<String>>;
  group: () => Promise<AsyncIterator<UserGroup>>;
  groupRequest: () => Promise<AsyncIterator<UserGroup>>;
  isAdmin: () => Promise<AsyncIterator<Boolean>>;
  avatar: () => Promise<AsyncIterator<String>>;
  metadata: () => Promise<AsyncIterator<Json>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  description: String;
  content?: String;
  unitPrice: Float;
  imageURLs: String[];
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  content: () => Promise<String>;
  unitPrice: () => Promise<Float>;
  imageURLs: () => Promise<String[]>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  unitPrice: () => Promise<AsyncIterator<Float>>;
  imageURLs: () => Promise<AsyncIterator<String[]>>;
}

export interface AggregateOrder {
  count: Int;
}

export interface AggregateOrderPromise
  extends Promise<AggregateOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderSubscription
  extends Promise<AsyncIterator<AggregateOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OfficialDocument {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  number: String;
  type?: OfficialDocumentType;
  other?: String;
  expiration?: DateTimeOutput;
}

export interface OfficialDocumentPromise
  extends Promise<OfficialDocument>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  number: () => Promise<String>;
  type: () => Promise<OfficialDocumentType>;
  other: () => Promise<String>;
  expiration: () => Promise<DateTimeOutput>;
  owner: <T = UserPromise>() => T;
}

export interface OfficialDocumentSubscription
  extends Promise<AsyncIterator<OfficialDocument>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  number: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<OfficialDocumentType>>;
  other: () => Promise<AsyncIterator<String>>;
  expiration: () => Promise<AsyncIterator<DateTimeOutput>>;
  owner: <T = UserSubscription>() => T;
}

export interface OfficialDocumentNullablePromise
  extends Promise<OfficialDocument | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  number: () => Promise<String>;
  type: () => Promise<OfficialDocumentType>;
  other: () => Promise<String>;
  expiration: () => Promise<DateTimeOutput>;
  owner: <T = UserPromise>() => T;
}

export interface OperatingPeriodEdge {
  node: OperatingPeriod;
  cursor: String;
}

export interface OperatingPeriodEdgePromise
  extends Promise<OperatingPeriodEdge>,
    Fragmentable {
  node: <T = OperatingPeriodPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OperatingPeriodEdgeSubscription
  extends Promise<AsyncIterator<OperatingPeriodEdge>>,
    Fragmentable {
  node: <T = OperatingPeriodSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductCategorySubscriptionPayload {
  mutation: MutationType;
  node: ProductCategory;
  updatedFields: String[];
  previousValues: ProductCategoryPreviousValues;
}

export interface ProductCategorySubscriptionPayloadPromise
  extends Promise<ProductCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductCategoryPreviousValuesPromise>() => T;
}

export interface ProductCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductCategoryPreviousValuesSubscription>() => T;
}

export interface OfficialDocumentConnection {
  pageInfo: PageInfo;
  edges: OfficialDocumentEdge[];
}

export interface OfficialDocumentConnectionPromise
  extends Promise<OfficialDocumentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OfficialDocumentEdge>>() => T;
  aggregate: <T = AggregateOfficialDocumentPromise>() => T;
}

export interface OfficialDocumentConnectionSubscription
  extends Promise<AsyncIterator<OfficialDocumentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OfficialDocumentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOfficialDocumentSubscription>() => T;
}

export interface ProductCategoryPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface ProductCategoryPreviousValuesPromise
  extends Promise<ProductCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface ProductCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLesson {
  count: Int;
}

export interface AggregateLessonPromise
  extends Promise<AggregateLesson>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLessonSubscription
  extends Promise<AsyncIterator<AggregateLesson>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Venue {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  address: String;
  placeID?: String;
  latitude?: Float;
  longitude?: Float;
}

export interface VenuePromise extends Promise<Venue>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  placeID: () => Promise<String>;
  latitude: () => Promise<Float>;
  longitude: () => Promise<Float>;
  spaces: <T = FragmentableArray<Space>>(args?: {
    where?: SpaceWhereInput;
    orderBy?: SpaceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface VenueSubscription
  extends Promise<AsyncIterator<Venue>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  placeID: () => Promise<AsyncIterator<String>>;
  latitude: () => Promise<AsyncIterator<Float>>;
  longitude: () => Promise<AsyncIterator<Float>>;
  spaces: <T = Promise<AsyncIterator<SpaceSubscription>>>(args?: {
    where?: SpaceWhereInput;
    orderBy?: SpaceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface VenueNullablePromise
  extends Promise<Venue | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  placeID: () => Promise<String>;
  latitude: () => Promise<Float>;
  longitude: () => Promise<Float>;
  spaces: <T = FragmentableArray<Space>>(args?: {
    where?: SpaceWhereInput;
    orderBy?: SpaceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ItemEdge {
  node: Item;
  cursor: String;
}

export interface ItemEdgePromise extends Promise<ItemEdge>, Fragmentable {
  node: <T = ItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ItemEdgeSubscription
  extends Promise<AsyncIterator<ItemEdge>>,
    Fragmentable {
  node: <T = ItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProgramSubscriptionPayload {
  mutation: MutationType;
  node: Program;
  updatedFields: String[];
  previousValues: ProgramPreviousValues;
}

export interface ProgramSubscriptionPayloadPromise
  extends Promise<ProgramSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProgramPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProgramPreviousValuesPromise>() => T;
}

export interface ProgramSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProgramSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProgramSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProgramPreviousValuesSubscription>() => T;
}

export interface EventConnection {
  pageInfo: PageInfo;
  edges: EventEdge[];
}

export interface EventConnectionPromise
  extends Promise<EventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventEdge>>() => T;
  aggregate: <T = AggregateEventPromise>() => T;
}

export interface EventConnectionSubscription
  extends Promise<AsyncIterator<EventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSubscription>() => T;
}

export interface ProgramPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  shortName: String;
  description?: String;
}

export interface ProgramPreviousValuesPromise
  extends Promise<ProgramPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  shortName: () => Promise<String>;
  description: () => Promise<String>;
}

export interface ProgramPreviousValuesSubscription
  extends Promise<AsyncIterator<ProgramPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  shortName: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDiscount {
  count: Int;
}

export interface AggregateDiscountPromise
  extends Promise<AggregateDiscount>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDiscountSubscription
  extends Promise<AsyncIterator<AggregateDiscount>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Space {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface SpacePromise extends Promise<Space>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  venue: <T = VenuePromise>() => T;
  events: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  sessions: <T = FragmentableArray<Session>>(args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SpaceSubscription
  extends Promise<AsyncIterator<Space>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  venue: <T = VenueSubscription>() => T;
  events: <T = Promise<AsyncIterator<EventSubscription>>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  sessions: <T = Promise<AsyncIterator<SessionSubscription>>>(args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SpaceNullablePromise
  extends Promise<Space | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  venue: <T = VenuePromise>() => T;
  events: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  sessions: <T = FragmentableArray<Session>>(args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DeviceEdge {
  node: Device;
  cursor: String;
}

export interface DeviceEdgePromise extends Promise<DeviceEdge>, Fragmentable {
  node: <T = DevicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DeviceEdgeSubscription
  extends Promise<AsyncIterator<DeviceEdge>>,
    Fragmentable {
  node: <T = DeviceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RoleSubscriptionPayload {
  mutation: MutationType;
  node: Role;
  updatedFields: String[];
  previousValues: RolePreviousValues;
}

export interface RoleSubscriptionPayloadPromise
  extends Promise<RoleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RolePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RolePreviousValuesPromise>() => T;
}

export interface RoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RolePreviousValuesSubscription>() => T;
}

export interface Role {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface RolePromise extends Promise<Role>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RoleSubscription
  extends Promise<AsyncIterator<Role>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RoleNullablePromise
  extends Promise<Role | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RolePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface RolePreviousValuesPromise
  extends Promise<RolePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface RolePreviousValuesSubscription
  extends Promise<AsyncIterator<RolePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface Event {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  subtitle?: String;
  organizer?: String;
  body: String;
  imageURL?: String;
  date: DateTimeOutput;
  access?: String;
  accessPoint?: String;
  target: UserGroup;
  status: AppNodeStatus;
}

export interface EventPromise extends Promise<Event>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  title: () => Promise<String>;
  subtitle: () => Promise<String>;
  organizer: () => Promise<String>;
  body: () => Promise<String>;
  imageURL: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  access: () => Promise<String>;
  accessPoint: () => Promise<String>;
  target: () => Promise<UserGroup>;
  status: () => Promise<AppNodeStatus>;
  place: <T = SpacePromise>() => T;
}

export interface EventSubscription
  extends Promise<AsyncIterator<Event>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = UserSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  subtitle: () => Promise<AsyncIterator<String>>;
  organizer: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  imageURL: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  access: () => Promise<AsyncIterator<String>>;
  accessPoint: () => Promise<AsyncIterator<String>>;
  target: () => Promise<AsyncIterator<UserGroup>>;
  status: () => Promise<AsyncIterator<AppNodeStatus>>;
  place: <T = SpaceSubscription>() => T;
}

export interface EventNullablePromise
  extends Promise<Event | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  title: () => Promise<String>;
  subtitle: () => Promise<String>;
  organizer: () => Promise<String>;
  body: () => Promise<String>;
  imageURL: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  access: () => Promise<String>;
  accessPoint: () => Promise<String>;
  target: () => Promise<UserGroup>;
  status: () => Promise<AppNodeStatus>;
  place: <T = SpacePromise>() => T;
}

export interface SpaceEdge {
  node: Space;
  cursor: String;
}

export interface SpaceEdgePromise extends Promise<SpaceEdge>, Fragmentable {
  node: <T = SpacePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SpaceEdgeSubscription
  extends Promise<AsyncIterator<SpaceEdge>>,
    Fragmentable {
  node: <T = SpaceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SessionSubscriptionPayload {
  mutation: MutationType;
  node: Session;
  updatedFields: String[];
  previousValues: SessionPreviousValues;
}

export interface SessionSubscriptionPayloadPromise
  extends Promise<SessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SessionPreviousValuesPromise>() => T;
}

export interface SessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SessionPreviousValuesSubscription>() => T;
}

export interface SocialLinkConnection {
  pageInfo: PageInfo;
  edges: SocialLinkEdge[];
}

export interface SocialLinkConnectionPromise
  extends Promise<SocialLinkConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SocialLinkEdge>>() => T;
  aggregate: <T = AggregateSocialLinkPromise>() => T;
}

export interface SocialLinkConnectionSubscription
  extends Promise<AsyncIterator<SocialLinkConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SocialLinkEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSocialLinkSubscription>() => T;
}

export interface SessionPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  closedAt: DateTimeOutput;
}

export interface SessionPreviousValuesPromise
  extends Promise<SessionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  closedAt: () => Promise<DateTimeOutput>;
}

export interface SessionPreviousValuesSubscription
  extends Promise<AsyncIterator<SessionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  closedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProgramEdge {
  node: Program;
  cursor: String;
}

export interface ProgramEdgePromise extends Promise<ProgramEdge>, Fragmentable {
  node: <T = ProgramPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProgramEdgeSubscription
  extends Promise<AsyncIterator<ProgramEdge>>,
    Fragmentable {
  node: <T = ProgramSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface News {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  subtitle?: String;
  body: String;
  imageURL?: String;
  expiration?: DateTimeOutput;
  category?: String;
  featured?: Boolean;
  target: UserGroup;
  status: AppNodeStatus;
}

export interface NewsPromise extends Promise<News>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  title: () => Promise<String>;
  subtitle: () => Promise<String>;
  body: () => Promise<String>;
  imageURL: () => Promise<String>;
  expiration: () => Promise<DateTimeOutput>;
  category: () => Promise<String>;
  featured: () => Promise<Boolean>;
  target: () => Promise<UserGroup>;
  status: () => Promise<AppNodeStatus>;
}

export interface NewsSubscription
  extends Promise<AsyncIterator<News>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = UserSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  subtitle: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  imageURL: () => Promise<AsyncIterator<String>>;
  expiration: () => Promise<AsyncIterator<DateTimeOutput>>;
  category: () => Promise<AsyncIterator<String>>;
  featured: () => Promise<AsyncIterator<Boolean>>;
  target: () => Promise<AsyncIterator<UserGroup>>;
  status: () => Promise<AsyncIterator<AppNodeStatus>>;
}

export interface NewsNullablePromise
  extends Promise<News | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  title: () => Promise<String>;
  subtitle: () => Promise<String>;
  body: () => Promise<String>;
  imageURL: () => Promise<String>;
  expiration: () => Promise<DateTimeOutput>;
  category: () => Promise<String>;
  featured: () => Promise<Boolean>;
  target: () => Promise<UserGroup>;
  status: () => Promise<AppNodeStatus>;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SocialLinkSubscriptionPayload {
  mutation: MutationType;
  node: SocialLink;
  updatedFields: String[];
  previousValues: SocialLinkPreviousValues;
}

export interface SocialLinkSubscriptionPayloadPromise
  extends Promise<SocialLinkSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SocialLinkPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SocialLinkPreviousValuesPromise>() => T;
}

export interface SocialLinkSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SocialLinkSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SocialLinkSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SocialLinkPreviousValuesSubscription>() => T;
}

export interface AggregateOfficialDocument {
  count: Int;
}

export interface AggregateOfficialDocumentPromise
  extends Promise<AggregateOfficialDocument>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOfficialDocumentSubscription
  extends Promise<AsyncIterator<AggregateOfficialDocument>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SocialLinkPreviousValues {
  id: ID_Output;
  link: String;
}

export interface SocialLinkPreviousValuesPromise
  extends Promise<SocialLinkPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  link: () => Promise<String>;
}

export interface SocialLinkPreviousValuesSubscription
  extends Promise<AsyncIterator<SocialLinkPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  link: () => Promise<AsyncIterator<String>>;
}

export interface LessonConnection {
  pageInfo: PageInfo;
  edges: LessonEdge[];
}

export interface LessonConnectionPromise
  extends Promise<LessonConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LessonEdge>>() => T;
  aggregate: <T = AggregateLessonPromise>() => T;
}

export interface LessonConnectionSubscription
  extends Promise<AsyncIterator<LessonConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LessonEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLessonSubscription>() => T;
}

export interface Department {
  id: ID_Output;
  name: String;
}

export interface DepartmentPromise extends Promise<Department>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  members: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DepartmentSubscription
  extends Promise<AsyncIterator<Department>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  members: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DepartmentNullablePromise
  extends Promise<Department | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  members: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DiscountRequestEdge {
  node: DiscountRequest;
  cursor: String;
}

export interface DiscountRequestEdgePromise
  extends Promise<DiscountRequestEdge>,
    Fragmentable {
  node: <T = DiscountRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DiscountRequestEdgeSubscription
  extends Promise<AsyncIterator<DiscountRequestEdge>>,
    Fragmentable {
  node: <T = DiscountRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SocialNetworkSubscriptionPayload {
  mutation: MutationType;
  node: SocialNetwork;
  updatedFields: String[];
  previousValues: SocialNetworkPreviousValues;
}

export interface SocialNetworkSubscriptionPayloadPromise
  extends Promise<SocialNetworkSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SocialNetworkPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SocialNetworkPreviousValuesPromise>() => T;
}

export interface SocialNetworkSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SocialNetworkSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SocialNetworkSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SocialNetworkPreviousValuesSubscription>() => T;
}

export interface AggregateDepartment {
  count: Int;
}

export interface AggregateDepartmentPromise
  extends Promise<AggregateDepartment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDepartmentSubscription
  extends Promise<AsyncIterator<AggregateDepartment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SocialNetworkPreviousValues {
  id: ID_Output;
  name: String;
  baseURL: String;
  ownURL: String;
}

export interface SocialNetworkPreviousValuesPromise
  extends Promise<SocialNetworkPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  baseURL: () => Promise<String>;
  ownURL: () => Promise<String>;
}

export interface SocialNetworkPreviousValuesSubscription
  extends Promise<AsyncIterator<SocialNetworkPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  baseURL: () => Promise<AsyncIterator<String>>;
  ownURL: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSubject {
  count: Int;
}

export interface AggregateSubjectPromise
  extends Promise<AggregateSubject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubjectSubscription
  extends Promise<AsyncIterator<AggregateSubject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TransactionPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  type: TxType;
  reference?: String;
  amount: Int;
}

export interface TransactionPreviousValuesPromise
  extends Promise<TransactionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<TxType>;
  reference: () => Promise<String>;
  amount: () => Promise<Int>;
}

export interface TransactionPreviousValuesSubscription
  extends Promise<AsyncIterator<TransactionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<TxType>>;
  reference: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateRole {
  count: Int;
}

export interface AggregateRolePromise
  extends Promise<AggregateRole>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoleSubscription
  extends Promise<AsyncIterator<AggregateRole>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SpaceSubscriptionPayload {
  mutation: MutationType;
  node: Space;
  updatedFields: String[];
  previousValues: SpacePreviousValues;
}

export interface SpaceSubscriptionPayloadPromise
  extends Promise<SpaceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SpacePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SpacePreviousValuesPromise>() => T;
}

export interface SpaceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SpaceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SpaceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SpacePreviousValuesSubscription>() => T;
}

export interface OrderConnection {
  pageInfo: PageInfo;
  edges: OrderEdge[];
}

export interface OrderConnectionPromise
  extends Promise<OrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderEdge>>() => T;
  aggregate: <T = AggregateOrderPromise>() => T;
}

export interface OrderConnectionSubscription
  extends Promise<AsyncIterator<OrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderSubscription>() => T;
}

export interface SpacePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface SpacePreviousValuesPromise
  extends Promise<SpacePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface SpacePreviousValuesSubscription
  extends Promise<AsyncIterator<SpacePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEvent {
  count: Int;
}

export interface AggregateEventPromise
  extends Promise<AggregateEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSubscription
  extends Promise<AsyncIterator<AggregateEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VenueConnection {
  pageInfo: PageInfo;
  edges: VenueEdge[];
}

export interface VenueConnectionPromise
  extends Promise<VenueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VenueEdge>>() => T;
  aggregate: <T = AggregateVenuePromise>() => T;
}

export interface VenueConnectionSubscription
  extends Promise<AsyncIterator<VenueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VenueEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVenueSubscription>() => T;
}

export interface SocialLink {
  id: ID_Output;
  link: String;
}

export interface SocialLinkPromise extends Promise<SocialLink>, Fragmentable {
  id: () => Promise<ID_Output>;
  link: () => Promise<String>;
  socialNetwork: <T = SocialNetworkPromise>() => T;
  owner: <T = UserPromise>() => T;
}

export interface SocialLinkSubscription
  extends Promise<AsyncIterator<SocialLink>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  link: () => Promise<AsyncIterator<String>>;
  socialNetwork: <T = SocialNetworkSubscription>() => T;
  owner: <T = UserSubscription>() => T;
}

export interface SocialLinkNullablePromise
  extends Promise<SocialLink | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  link: () => Promise<String>;
  socialNetwork: <T = SocialNetworkPromise>() => T;
  owner: <T = UserPromise>() => T;
}

export interface SubjectPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  shortName: String;
  description?: String;
}

export interface SubjectPreviousValuesPromise
  extends Promise<SubjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  shortName: () => Promise<String>;
  description: () => Promise<String>;
}

export interface SubjectPreviousValuesSubscription
  extends Promise<AsyncIterator<SubjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  shortName: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface SubjectSubscriptionPayload {
  mutation: MutationType;
  node: Subject;
  updatedFields: String[];
  previousValues: SubjectPreviousValues;
}

export interface SubjectSubscriptionPayloadPromise
  extends Promise<SubjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubjectPreviousValuesPromise>() => T;
}

export interface SubjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubjectPreviousValuesSubscription>() => T;
}

export interface SocialNetwork {
  id: ID_Output;
  name: String;
  baseURL: String;
  ownURL: String;
}

export interface SocialNetworkPromise
  extends Promise<SocialNetwork>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  baseURL: () => Promise<String>;
  ownURL: () => Promise<String>;
  userLinks: <T = FragmentableArray<SocialLink>>(args?: {
    where?: SocialLinkWhereInput;
    orderBy?: SocialLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SocialNetworkSubscription
  extends Promise<AsyncIterator<SocialNetwork>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  baseURL: () => Promise<AsyncIterator<String>>;
  ownURL: () => Promise<AsyncIterator<String>>;
  userLinks: <T = Promise<AsyncIterator<SocialLinkSubscription>>>(args?: {
    where?: SocialLinkWhereInput;
    orderBy?: SocialLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SocialNetworkNullablePromise
  extends Promise<SocialNetwork | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  baseURL: () => Promise<String>;
  ownURL: () => Promise<String>;
  userLinks: <T = FragmentableArray<SocialLink>>(args?: {
    where?: SocialLinkWhereInput;
    orderBy?: SocialLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SocialNetworkConnection {
  pageInfo: PageInfo;
  edges: SocialNetworkEdge[];
}

export interface SocialNetworkConnectionPromise
  extends Promise<SocialNetworkConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SocialNetworkEdge>>() => T;
  aggregate: <T = AggregateSocialNetworkPromise>() => T;
}

export interface SocialNetworkConnectionSubscription
  extends Promise<AsyncIterator<SocialNetworkConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SocialNetworkEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSocialNetworkSubscription>() => T;
}

export interface DiscountConnection {
  pageInfo: PageInfo;
  edges: DiscountEdge[];
}

export interface DiscountConnectionPromise
  extends Promise<DiscountConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DiscountEdge>>() => T;
  aggregate: <T = AggregateDiscountPromise>() => T;
}

export interface DiscountConnectionSubscription
  extends Promise<AsyncIterator<DiscountConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DiscountEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDiscountSubscription>() => T;
}

export interface NewsEdge {
  node: News;
  cursor: String;
}

export interface NewsEdgePromise extends Promise<NewsEdge>, Fragmentable {
  node: <T = NewsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NewsEdgeSubscription
  extends Promise<AsyncIterator<NewsEdge>>,
    Fragmentable {
  node: <T = NewsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductCategoryEdge {
  node: ProductCategory;
  cursor: String;
}

export interface ProductCategoryEdgePromise
  extends Promise<ProductCategoryEdge>,
    Fragmentable {
  node: <T = ProductCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductCategoryEdgeSubscription
  extends Promise<AsyncIterator<ProductCategoryEdge>>,
    Fragmentable {
  node: <T = ProductCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

export type Json = any;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "UserGroup",
    embedded: false
  },
  {
    name: "OfficialDocumentType",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "UserRoles",
    embedded: false
  },
  {
    name: "SocialLink",
    embedded: false
  },
  {
    name: "SocialNetwork",
    embedded: false
  },
  {
    name: "OfficialDocument",
    embedded: false
  },
  {
    name: "Address",
    embedded: false
  },
  {
    name: "DeviceType",
    embedded: false
  },
  {
    name: "Device",
    embedded: false
  },
  {
    name: "AppNodeStatus",
    embedded: false
  },
  {
    name: "News",
    embedded: false
  },
  {
    name: "Event",
    embedded: false
  },
  {
    name: "Venue",
    embedded: false
  },
  {
    name: "Space",
    embedded: false
  },
  {
    name: "Department",
    embedded: false
  },
  {
    name: "Program",
    embedded: false
  },
  {
    name: "Branch",
    embedded: false
  },
  {
    name: "Subject",
    embedded: false
  },
  {
    name: "Lesson",
    embedded: false
  },
  {
    name: "OperatingPeriod",
    embedded: false
  },
  {
    name: "Session",
    embedded: false
  },
  {
    name: "LessonSessions",
    embedded: false
  },
  {
    name: "LessonsTeachers",
    embedded: false
  },
  {
    name: "ProductCategory",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "Discount",
    embedded: false
  },
  {
    name: "DiscountRequest",
    embedded: false
  },
  {
    name: "TxType",
    embedded: false
  },
  {
    name: "Transaction",
    embedded: false
  },
  {
    name: "Order",
    embedded: false
  },
  {
    name: "Item",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
